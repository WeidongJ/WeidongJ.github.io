---
title: 算法图解学习笔记
date: 2019-05-12 14:18:33
tags:
    - python
    - 算法图解
categories:
    - 学习
comments: true
description:  算法图解学习笔记
---

## 第一章 算法简介

二分查找：时间复杂度O(log n),

实现：

    # 二分法
    def binary_search(list, item):
        low = 0
        high = len(list)-1

        while low <= high:
            mid = (low +high)//2
            guess = list[mid]
            if guess == item:
                return mid
            if guess < item:
                low = mid +1
            else:
                high = mid -1
        return None

大O表示法：O(logn),大O表示法指出了最糟情况下的运行时间。

## 第二章 选择排序

链表：顾名思义，每个元素连接着下一个元素（存储了下一个元素的位置）
优势：插入和删除元素方便，存储在内存中的任意位置

数组：所有元素存储在一起，优势在于随机读取

选择排序：遍历数组找出最大或者最小的数放入新的数组中，对剩余的元素继续遍历，直到数组为空。
时间复杂度 O(n2)，实现：

    # 选择排序
    def selectionSorted(arr):
        newArr = []
        for i in range(len(arr)):
            smallest = arr[0]
            smallest_index = 0
            for j in range(1,len(arr)):
                if arr[j] < smallest:
                    smallest = arr[j]
                    smallest_index = j
            newArr.append(arr.pop(smallest_index))

        return newArr


冒泡排序：遍历数组，比较每个元素两两大小，将大的或小的值交换，对剩余元素继续遍历。
时间复杂度 O(n2)，实现：
```
# 冒泡排序 
def bubble_sorted(arr):
    for i in range(len(arr)-1):
        for j in range(len(arr)-i-1):
            if arr[j] > arr[j+1]:
                temp = arr[j]
                arr[j] = arr[j+1]
                arr[j+1] = temp
    return arr
```
## 第三章 递归

**递归**：返回时调用自己。只是在结构上更加清晰，没有性能上的优势，“如果使用循环，程序的性能可能更高；如果使用递归，程序可能更容易理解。如何选择要看什么对你来说更重要。”

**栈**：一种先入后出的队列，调用栈只支持2种操作：压入（插入）和弹出（删除并读取）


## 第四章 快速排序

核心：取第一个元素作为基准值povit，其余元素与其对比，小的放入less组，大的放入glter组，返回新的数组`less+povit+glter`,对返回的数据进行同样的操作。
时间复杂度 O(n log n), 实现：
```
# 快速排序
def quicksort(arr):
    if len(arr) < 2:
        return arr
    else:
        pivot = arr[0]
        less = [i for i in arr[1:] if i <= pivot]
        glter = [i for i in arr[1:] if i > pivot]

        return quicksort(less) +[pivot] + quicksort(glter)
```

**分而治之**（divide and conquer，D&C）：我的理解就是分成等分之后再处理。
**欧几里得算法**：2个数的最大公约数，等于较小数与2者差值的最大公约数
## 第五章 散列表

列表：

冲突：如果两个键映射到了同一个位置

解决方法：使用链表
影响列表速度的关键：
1. 装填因子：元素总数/位置总数，装因子越低，发生冲突的可能性越小，散列表的性能越高。一个不错的经验规则是：一旦填装因子大于0.7，就调整散列表的长度
2. 良好的散列函数，良好的散列函数让数组中的值呈均匀分布。

## 第六章 广度优先搜索

**广度优先搜索**：解决最短路径问题的算法。例如查找整个人际关系网查找水果经销商。主要解决2类问题：
* 从节点A出发有到达B的路径吗？
* 从节点A到达节点B的最短路径是什么？

*队列*：实现广度优先搜索的顺序检查的方式；和生活中的排队一样，类似于栈只支持2中操作：*入队*和*出队*。
与栈的区别：
* 队列：先进先出
* 栈：先进后出

**图**：图模拟一组连接，由节点（node）和边（edge）组成，一些名词：
* 一度关系：节点的邻居
* 二度关系：邻居的邻居

有向图：有箭头指向。
树：类似家谱，所有边都是向下指。

实现：通过dict实现，节点和邻居的关系，并实现邻居与邻居的联系
算法：python可以使用deque创建双端队列

时间复杂度 O(V + E)，其中V为顶点（vertice）数，E为边数

实现：
```
# 广度优先搜索
from collections import deque
def person_is_seller(person): # 指定名字最后以m结尾的是经销商
    return person[-1] == "y"

graph = {} 
graph["you"] = ["alice", "bob", "claire"] 
graph["bob"] = ["anuj", "peggy"] 
graph["alice"] = ["peggy"] 
graph["claire"] = ["thom", "jonny"] 
graph["anuj"] = [] 
graph["peggy"] = [] 
graph["thom"] = [] 
graph["jonny"] = []

def search(name):
    search_queue = deque()
    search_queue += graph[name]
    searched = []
    while search_queue:
        person = search_queue.popleft()
        if not person in searched:
            if person_is_seller(person):
                print(person + ' is a mango seller')
                return True # return 会退出函数
            else:
                search_queue += graph[person]
                searched.append(person)
    return False
```

*问题*：同一个节点由于可能同时是多个节点的邻居可能会多次进入队列，也会出现无线循环的情况：
解决方法：标记节点已经检查。

## 第七章 狄克斯特拉算法
核心：*找出图中最便宜的节点，并确保没有到该节点更便宜的路径*。
适用场景：有向图，不含负加权（**这是因为狄克斯特拉算法这样假设：对于处理过的海报节点，没有前往该节点的更短路径。这种假设仅在没有负权边时才成立**）。

时间复杂度 O(V + E)，其中V为顶点（vertice）数，E为边数

实现：
```
# 狄克斯特拉算法

graph_weight = {}
# 起点的邻居
graph_weight['start'] = {}
graph_weight['start']['a'] = 6
graph_weight['start']['b'] = 2

# a的邻居
graph_weight['a'] = {}
graph_weight['a']['fin'] = 1

# b 的邻居
graph_weight['b'] = {}
graph_weight['b']['a'] = 3
graph_weight['b']['fin'] = 5

# 终点
graph_weight['fin'] = {}

# 开销

infinity = float('inf')
costs = {}
costs['a'] = 6
costs['b'] = 2
costs['fin'] = infinity

# 父节点
parents = {}
parents['a'] = 'start'
parents['b'] = 'start'
parents['fin'] = None

processed = []
# 找出开销最低的节点

def find_lowest_cost_node(costs):
    lowest_cost = float('inf')
    lowest_cost_node = None
    for node in costs:
        cost = costs[node]
        if cost < lowest_cost and node not in processed:
            lowest_cost = cost
            lowest_cost_node = node
    return lowest_cost_node


node = find_lowest_cost_node(costs)

while node is not None:
    cost =  costs[node]
    neighbors = graph_weight[node]
    for n in neighbors.keys():
        new_cost = cost + neighbors[n]
        if costs[n] > new_cost:
            costs[n] = new_cost
            parents[n] = node
    processed.append(node)
    node = find_lowest_cost_node(costs)
```

## 第八章 贪婪算法
每次都取最优解，
优劣评判标准：
* 速度有多快
* 得到的近似解与最优解的接近程度
**NP完全问题**：以难解著称的问题。
时间复杂度 O(n2)
实现：
```
# 贪婪算法

states_need = set(['mt', 'wa', 'or', 'id', 'nv', 'ut', 'ca', 'az'])

stations = {}
stations['kone'] = set(['id', 'nv', 'ut'])
stations['ktwo'] = set(['wa', 'id', 'mt'])
stations['kthree'] = set(['or', 'nv', 'ca'])
stations['kfour'] = set(['nv', 'ut'])
stations['ktfive'] = set(['ca', 'az'])

final_stations = set()

# 实现
while states_need:
    best_station = None
    states_covered = set()

    for station, states_for_station in stations.items():
        covered = states_need & states_for_station
        if len(covered) > len(states_covered):
            best_station = station
            states_covered = covered
    final_stations.add(best_station)
    states_need -= states_covered
```

## 第九章 动态规划
限制：*动态规划功能强大，它能够解决子问题并使用这些答案来解决大问题。但仅当每个子问题都是离散的，即不依赖于其他子问题时，动态规划才管用*
**2种计算维度**：
* 比较最长公共子串：两个字符串都包含的最长子串的长度，伪代码：

        if word_a[i] == word_b[j]: 
            cell[i][j] = cell[i-1][j-1] + 1 
        else: 
            cell[i][j] = 0 
* 最长公共子序列：两个单词中都有的序列包含的字母数，伪代码：

        if word_a[i] == word_b[j]:
            cell[i][j] = cell[i-1][j-1] + 1 
        else: 
            cell[i][j] = max(cell[i-1][j], cell[i][j-1])
应用：DNA相似度，git diff的实现

具体适用场景：
* 需要在给定约束条件下优化某种指标时，动态规划很有用。
* 问题可以分为离散问题时，可以使用动态规划来解决。
* 每种动态规划都涉及网络。
* 单元格的值就是要优化的值。
* 每一个单元格都是一个子问题，因此需要将问题划分为子问题。
* 计算动态规划的公式不唯一。


## 第十章 K最近邻算法
K最近邻算法（KNN）：
1. 对一个水果进行分类
2. 查看他的最近3个邻居
3. 邻居中最多的种类，是可能的类型

回归：计算出邻居的平局值

**机器学习**：
OCR（图像识别）原理，
1. 浏览大量数字图片，提取数字图片特征（线，点，曲线特征）。--**训练**
2. 遇到新图像时，提取图像的特征，找出他最近的邻居。

***总结*：
* KNN就是用于分类和回归，需要考虑最近的邻居
* 分类就是编组
* 回归就是预测结果
* 特征抽取意味着将物品转换为一系列可比较的数字
* 能否挑选合适的特征事关KNN算法的成败

## 第十一章 十种算法

### 二叉树
定义：对于每一个节点，左子节点的值都比他小，右子节点的值都比他大
对比快速排序：
* 优点：二叉树查找法的插入和删除速度要快的很多；
* 缺点：不能随机访问

扩展：*堆*：又被为优先队列(priority queue)。尽管名为优先队列，但堆并不是队列。回忆一下，在队列中，我们可以进行的限定操作是dequeue和enqueue。dequeue是按照进入队列的先后顺序来取出元素。而在堆中，我们不是按照元素进入队列的先后顺序取出元素的，而是按照元素的优先级取出元素。[堆](https://www.cnblogs.com/vamei/archive/2013/03/20/2966612.html)

插入：进行名为`[precolate_up`的操作：在树的最后插入元素，和其父节点比较优先级大小，比父节点大就进行交换，直到优先级小于父节点。

删除：只能删除根节点，成为2个子树；让最后一个元素（last）成为根节点，进行`precolate_down`操作，不断比较last节点和子节点的优先级大小，如果last的优先级比2个子结点中小的那个大，则和其交换位置。

### 反向索引
定义：字典的key为单词，值为所在的页码

作用：用于搜索引擎

### 傅里叶变换 ？？

### 并行算法
主要的问题：
1. 并行性管理开销：如何合理分配任务，如何有效合并任务
2. 负载均衡：如何均匀的分配任务，让各个内核的任务达到负载均衡

**MapReduce**：流行的分布式算法

map（映射函数）：接受一个数组，并对每个元素执行同样的操作

reduce（归并函数）：将一个数组转化成一个元素。

### 概率性算法
**布隆过滤器**：一种概率性的数据结构，结果可能不对，很可能是正确的
* 可能出错的情况：指出结果是正确时，结果可能是错误的
* 不可能错误的情况：指出结果是错误的情况时
**HyperLogLog**

### SHA算法
散列函数：即反向索引
安全散列算法函数（SHA）：给定一个字符串，返回其散列值。**无法根据散列值推算出字符串**
特点：局部不敏感：改动一个字符串，返回的散列值没有任何的相似性，

### Diffie-Hellman 密钥交换
特点:公钥和私钥结合使用：使用公钥生成散列值，使用私钥揭秘散列值。

### 线性规划：即使用方程求最优化解




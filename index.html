<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="PrueMat">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="PrueMat">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="PrueMat">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>PrueMat</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">PrueMat</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-schedule">
          <a href="/schedule/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-calendar"></i> <br>
            
            日程表
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/10/MDN-web/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Weidong Ji">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PrueMat">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/10/MDN-web/" itemprop="url">MDN-学习</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-10T09:39:01+08:00">
                2019-06-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/08/python基础知识复习/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Weidong Ji">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PrueMat">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/08/python基础知识复习/" itemprop="url">python基础知识复习</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-08T09:39:01+08:00">
                2019-06-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="数据类型和变量"><a href="#数据类型和变量" class="headerlink" title="数据类型和变量"></a>数据类型和变量</h2><ul>
<li>python中int没有大小限制， 无限大可以使用<code>inf</code>来表示；常量通常使用大写字母表示。</li>
<li><p><code>utf-8</code>是可变长编码：可以根据一个Unicode字符根据字节大小编码成1-6个字节；计算机中编码的工作方式如下：</p>
<p>  用记事本编辑的时候，从文件读取的UTF-8字符被转换为Unicode字符到内存里，编辑完成后，保存的时候再把Unicode转换为UTF-8保存到文件:</p>
<img src="/2019/06/08/python基础知识复习/encode.png" title="encode"></li>
<li><code>ord()</code>函数可以获取字符的整数表示，<code>chr()</code>可以把编码转换成对应的字符。</li>
<li><p>bytes类型的数据用<code>b&#39;ABC&#39;</code>表示，与字符串<code>ABC</code>的差别是bytes类型每个字符只占一个字节。把字符串转换成bytes型使用<code>encode()</code>方法，使用<code>decode()</code>可以把bytes转换成字符串。</p>
<pre><code>&gt;&gt;&gt; &apos;中文&apos;.encode(&apos;utf-8&apos;)
b&apos;\xe4\xb8\xad\xe6\x96\x87&apos;
</code></pre></li>
<li>dict的key必须是不可变对象，因为dict是根据key来计算存储位置，key可变，dict内部就全乱了。</li>
<li><p><strong>zip()</strong>：函数用于将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的列表，如果各个迭代器的元素个数不一致，则返回列表长度与最短的对象相同，利用 * 号操作符，可以将元组解压为列表。</p>
<pre><code>&gt;&gt;&gt;a = [1,2,3]
&gt;&gt;&gt; b = [4,5,6]
&gt;&gt;&gt; c = [4,5,6,7,8]
&gt;&gt;&gt; zipped = zip(a,b)     # 打包为元组的列表
[(1, 4), (2, 5), (3, 6)]
&gt;&gt;&gt; zip(a,c)              # 元素个数与最短的列表一致
[(1, 4), (2, 5), (3, 6)]
&gt;&gt;&gt; zip(*zipped)          # 与 zip 相反，*zipped 可理解为解压，返回二维矩阵式
[(1, 2, 3), (4, 5, 6)]
</code></pre></li>
</ul>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数名其实就是指向一个函数对象的引用，完全可以把函数名赋给一个变量，相当于给这个函数起了一个“别名”：</p>
<pre><code>&gt;&gt;&gt; a = abs # 变量a指向abs函数
&gt;&gt;&gt; a(-1) # 所以也可以通过a调用abs函数
1
</code></pre><h3 id="函数的参数"><a href="#函数的参数" class="headerlink" title="函数的参数"></a>函数的参数</h3><p>默认参数</p>
<pre><code>def power(x, n=2):
    s = 1
    while n &gt; 0:
        n = n - 1
        s = s * x
    return s
</code></pre><p>默认参数必须指向不变对象：Python函数在定义的时候，默认参数L的值就被计算出来了，即[]，因为默认参数L也是一个变量，它指向对象[]，每次调用该函数，如果改变了L的内容，则下次调用时，默认参数的内容就变了，不再是函数定义时的[]了。</p>
<pre><code>def add_end(L=[]):
    L.append(&apos;END&apos;)
    return L

&gt;&gt;&gt; add_end()
[&apos;END&apos;, &apos;END&apos;]
&gt;&gt;&gt; add_end()
[&apos;END&apos;, &apos;END&apos;, &apos;END&apos;]
</code></pre><p>可变参数：<br>    def calc(<em>numbers):<br>        sum = 0<br>        for n in numbers:<br>            sum = sum + n </em> n<br>        return sum<br>*nums表示把nums这个list的所有元素作为可变参数传进去。这种写法相当有用，而且很常见：</p>
<pre><code>&gt;&gt;&gt; nums = [1, 2, 3]
&gt;&gt;&gt; calc(*nums)
14
</code></pre><p>递归：函数内部调用自己本身。</p>
<p>使用递归需要注意防止栈溢出。可以使用尾递归优化，尾递归即调用自己本身时 return语句不包含表达式，效果等同于循环。</p>
<pre><code># 汉诺塔移动
def move(n, a, b, c):
    if n == 1:
        print(a, &apos;--&gt;&apos;, c)
    else:
        move(n-1, a, c, b)
        move(1, a, b, c)
        move(n-1, b, c, a)
</code></pre><h3 id="函数高级特性"><a href="#函数高级特性" class="headerlink" title="函数高级特性"></a>函数高级特性</h3><p>python内置函数<code>enumerate()</code>可以把列表变成一个索引-元素对。</p>
<pre><code>&gt;&gt;&gt; for i, value in enumerate([&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]):
...     print(i, value)
...
0 A
1 B
2 C
</code></pre><p><strong>生成式（generate）</strong>：列表元素根据某种算法推算出来，循环种不对退算后面的数，不需要创建完整的列表，以节省大量的空间；使用()创建一个生成器，列表生成式使用[]，使用next()获取下一个返回值，最后抛出StopIteration异常。</p>
<p>斐波拉契数列：</p>
<pre><code># 列表生成式
def fib(x):
    n, a, b = 0, 0, 1
    while n &lt; max:
        print(b)
        a, b = a, a + b
        n += 1
    return &apos;done&apos;
</code></pre><p>generator的另一种方法。如果一个函数定义中包含yield关键字，那么这个函数就不再是一个普通函数，而是一个generator：</p>
<pre><code># 生成器
def fib(x):
    n, a, b = 0, 0, 1
    while n &lt; max:
        yield b
        a, b = a, a + b
        n += 1
    return &apos;done&apos;
</code></pre><p>最难理解的就是generator和函数的执行流程不一样。函数是顺序执行，遇到return语句或者最后一行函数语句就返回。而变成generator的函数，<strong>在每次调用next()的时候执行，遇到yield语句返回，再次执行时从上次返回的yield语句处继续执行。</strong></p>
<pre><code>def odd():
print(&apos;step 1&apos;)
yield 1
print(&apos;step 2&apos;)
yield(3)
print(&apos;step 3&apos;)
yield(5)

&gt;&gt;&gt; o = odd()
&gt;&gt;&gt; next(o)
step 1
1
&gt;&gt;&gt; next(o)
step 2
3
&gt;&gt;&gt; next(o)
step 3
5
&gt;&gt;&gt; next(o)
Traceback (most recent call last):
File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
StopIteration
</code></pre><p>杨辉三角：<br>    def trangles():<br>        L = [1]<br>        while True:<br>            yield L<br>            L = [1] + [L[a] + L[a+1] for a in range(0,len(L)-1)] + [1]</p>
<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><ul>
<li>可以直接作用于for循环的对象统称为可迭代对象：<strong>Iterable</strong>。</li>
<li>可以被next()函数调用并不断返回下一个值的对象称为迭代器：<strong>Iterator</strong>。</li>
</ul>
<p>Python的Iterator对象表示的是一个数据流，Iterator对象可以被next()函数调用并不断返回下一个数据，直到没有数据时抛出StopIteration错误。可以把这个数据流看做是一个有序序列，但我们却不能提前知道序列的长度，只能不断通过next()函数实现按需计算下一个数据，所以Iterator的计算是惰性的，只有在需要返回下一个数据时它才会计算。Iterator甚至可以表示一个无限大的数据流，例如全体自然数。而使用list是永远不可能存储全体自然数的。</p>
<p>Python的for循环本质上就是通过不断调用next()函数实现的</p>
<h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h2><p>函数式编程就是一种抽象程度很高的编程范式，纯粹的函数式编程语言编写的函数没有变量，因此，任意一个函数，只要输入是确定的，输出就是确定的，这种纯函数我们称之为没有副作用。而允许使用变量的程序设计语言，由于函数内部的变量状态不确定，同样的输入，可能得到不同的输出，因此，这种函数是有副作用的。</p>
<p>函数式编程的一个特点就是，允许把函数本身作为参数传入另一个函数，还允许返回一个函数！</p>
<h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><p>一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数</p>
<p>变量可以指向函数</p>
<pre><code>&gt;&gt;&gt; f = abs
&gt;&gt;&gt; f(-10)
10
</code></pre><h3 id="map-reduce"><a href="#map-reduce" class="headerlink" title="map()/reduce()"></a>map()/reduce()</h3><p><code>map()</code>函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的<strong>Iterator</strong>返回。</p>
<pre><code>&gt;&gt;&gt; list(map(str, [1, 2, 3, 4, 5, 6, 7, 8, 9]))
[&apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos;]
</code></pre><p><code>reduce()</code>把一个函数作用在一个序列[x1, x2, x3, …]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算，其效果就是。</p>
<pre><code>&gt;&gt;&gt; from functools import reduce
&gt;&gt;&gt; def add(x, y):
...     return x + y
...
&gt;&gt;&gt; reduce(add, [1, 3, 5, 7, 9])
25
</code></pre><p><code>filter()</code>也接收一个函数和一个序列。和map()不同的是，filter()把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素,返回一个<strong>Iterator</strong>。</p>
<p><code>sorted()</code>排序</p>
<pre><code>&gt;&gt;&gt; sorted([&apos;bob&apos;, &apos;about&apos;, &apos;Zoo&apos;, &apos;Credit&apos;], key=str.lower, reverse=True)
[&apos;Zoo&apos;, &apos;Credit&apos;, &apos;bob&apos;, &apos;about&apos;]
</code></pre><h3 id="返回函数"><a href="#返回函数" class="headerlink" title="返回函数"></a>返回函数</h3><p>高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回。</p>
<pre><code>def lazy_sum(*args):
    def sum():
        ax = 0
        for n in args:
            ax = ax + n
        return ax
    return sum
</code></pre><p>调用<code>lazy_sum()</code>时，返回求和函数；并且每次调用时都返回一个新的函数：</p>
<pre><code>&gt;&gt;&gt; f = lazy_sum(1, 3, 5, 7, 9)
&gt;&gt;&gt; f
&lt;function lazy_sum.&lt;locals&gt;.sum at 0x101c6ed90&gt;

&gt;&gt;&gt; f1 = lazy_sum(1, 3, 5, 7, 9)
&gt;&gt;&gt; f2 = lazy_sum(1, 3, 5, 7, 9)
&gt;&gt;&gt; f1==f2
False
</code></pre><p>闭包：我们在函数<code>lazy_sum</code>中又定义了函数<code>sum</code>，并且，内部函数<code>sum</code>可以引用外部函数<code>lazy_sum</code>的参数和局部变量，当<code>lazy_sum</code>返回函数<code>sum</code>时，<strong>相关参数和变量都保存在返回的函数中</strong>，这种称为“闭包（Closure）”的程序结构拥有极大的威力。</p>
<p>返回的函数并没有立刻执行，而是直到调用了f()才执行。</p>
<pre><code>def count():
    fs = []
    for i in range(1, 4):
        def f():
            return i*i
        fs.append(f)
    return fs

f1, f2, f3 = count()
&gt;&gt;&gt; f1()
9
&gt;&gt;&gt; f2()
9
&gt;&gt;&gt; f3()
9
</code></pre><p>全部都是9！原因就在于返回的函数引用了变量i，但它并非立刻执行。等到3个函数都返回时，它们所引用的变量i已经变成了3，因此最终结果为9。<strong>返回闭包时牢记一点：返回函数不要引用任何循环变量，或者后续会发生变化的变量。</strong></p>
<p>一定要引用循环变量怎么办？方法是再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变:<br>    def count():<br>        def f(j):<br>            def g():<br>                return j*j<br>            return g<br>        fs = []<br>        for i in range(1, 4):<br>            fs.append(f(i)) # f(i)立刻被执行，因此i的当前值被传入f()<br>        return fs # 返回一个列表</p>
<p>计数器：</p>
<pre><code>def createCounter():
    li = 0
    def counter():
        li += 1
        return li
    return counter
</code></pre><p>上述代码会报错：当你在当前作用域中的给变量赋值时，该变量将成为该作用域的局部变量，并在外部范围中隐藏任何类似命名的变量。</p>
<pre><code>def createCounter():
    l = [0]
    def counter():
        l[0] = l[0] + 1
        return l[0]
    return counter
</code></pre><h3 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h3><p>在代码运行期间动态增加功能的方式，成为<strong>装饰器（Decorator）</strong>；本质上decorator就是一个返回函数的高阶函数。</p>
<pre><code># 装饰器
def log(func):
    @functools.wraps(func)
    def wrapper(*args, **kw):
        print(&apos;call %s()&apos; % func.__name__)
        return func(*args, **kw)
    return wrapper

@log
def now():
    print(&apos;Hello World!&apos;)

def log_text(text):
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kw):
            print(&apos;%s %s()&apos; % (text, func.__name__))
            return func(*args, **kw)
        return wrapper
    return decorator

@log_text(&apos;调用&apos;)
def new_now():
    print(&apos;Hello World!&apos;)
</code></pre><p>Python内置的<code>functools.wraps</code>，把原始函数的<code>__name__</code>属性复制到<code>wrapper()</code>中.</p>
<p>偏函数</p>
<p><code>functools.partial</code>的作用就是，把一个函数的某些参数给固定住（也就是设置默认值），返回一个新的函数，调用这个新函数会更简单。</p>
<pre><code>&gt;&gt;&gt; import functools
&gt;&gt;&gt; int2 = functools.partial(int, base=2)
&gt;&gt;&gt; int2(&apos;1000000&apos;)
64
</code></pre><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p><code>sys</code>模块有一个<code>argv</code>变量，用list存储了命令行的所有参数。运行python3 hello.py Michael获得的sys.argv就是[‘hello.py’, ‘Michael]。</p>
<p>当我们在命令行运行hello模块文件时，Python解释器把一个特殊变量<code>__name__</code>置为<code>__main__</code>，而如果在其他地方导入该hello模块时，if判断将失败，因此，这种if测试可以让一个模块通过命令行运行时执行一些额外的代码，最常见的就是运行测试</p>
<pre><code>if __name__==&apos;__main__&apos;:
test()
</code></pre><h2 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h2><p>类和实例</p>
<p>和静态语言不同，Python允许对实例变量绑定任何数据，也就是说，对于两个实例变量，虽然它们都是同一个类的不同实例，但拥有的变量名称都可能不同。</p>
<p>访问限制</p>
<p>使用<code>__</code>限制属性访问，改为增加<code>get/se</code>t方法是因为<strong>在方法中可以对参数做检查</strong>。</p>
<ul>
<li><code>__xxx__</code> 特殊变量。</li>
<li><code>_xxx</code> 约定的私有变量：虽然我可以被访问，但是，请把我视为私有变量，不要随意访问。</li>
<li><code>__xx</code> 私有变量，python解释器把<code>__xx</code>对外改变成<code>_ClassName__xx</code></li>
</ul>
<p>外部设置变量错误，际上这个<strong>name变量和class内部的</strong>name变量不是一个变量！内部的<strong>name变量已经被Python解释器自动改成了_Student</strong>name，而外部代码给bart新增了一个__name变量：</p>
<pre><code>&gt;&gt;&gt; bart = Student(&apos;Bart Simpson&apos;, 59)
&gt;&gt;&gt; bart.get_name()
&apos;Bart Simpson&apos;
&gt;&gt;&gt; bart.__name = &apos;New Name&apos; # 设置__name变量！
&gt;&gt;&gt; bart.__name
&apos;New Name&apos;
</code></pre><h3 id="继承和多态"><a href="#继承和多态" class="headerlink" title="继承和多态"></a>继承和多态</h3><p><strong>继承</strong>：子类获得了父类的全部功能。</p>
<p><strong>多态</strong>：对于一个变量，我们只需要知道它是Animal类型，无需确切地知道它的子类型，就可以放心地调用run()方法，而具体调用的run()方法是作用在Animal、Dog、Cat还是Tortoise对象上，由运行时该对象的确切类型决定，这就是多态真正的威力：调用方只管调用，不管细节，而当我们新增一种Animal的子类时，只要确保run()方法编写正确，不用管原来的代码是如何调用的。这就是著名的“开闭”原则：</p>
<pre><code>class Animal(object):
def run(self):
    print(&apos;Animal is running...&apos;)

class Dog(Animal):
    def run(self):
        print(&apos;Dog is running...&apos;)

def run_twice(animal):
    animal.run()
    animal.run()

run_twice(Animal())
run_twice(Dog())

Animal is running...
Animal is running...
Dog is running...
Dog is running...
</code></pre><ul>
<li>对扩展开放：允许新增Animal子类。</li>
<li>对修改封闭：不需要修改依赖Animal类型的run_twice()等函数。</li>
</ul>
<p>动态语言vs静态语言</p>
<p>对于静态语言（例如Java）来说，如果需要传入Animal类型，则传入的对象必须是Animal类型或者它的子类，否则，将无法调用run()方法。</p>
<p>对于Python这样的动态语言来说，则不一定需要传入Animal类型。我们只需要保证传入的对象有一个run()方法就可以了：</p>
<pre><code>class Timer(object):
    def run(self):
        print(&apos;start...&apos;)

run_twice(Timer())

start...
start...
</code></pre><p>这就是动态语言的“<strong>鸭子类型</strong>”，它并不要求严格的继承体系，一个对象只要“看起来像鸭子，走起路来像鸭子”，那它就可以被看做是鸭子。</p>
<h3 id="获取对象信息"><a href="#获取对象信息" class="headerlink" title="获取对象信息"></a>获取对象信息</h3><p><code>type()</code>用于判断对象的类型,使用<code>isinstance()</code>判断继承关系。</p>
<p><code>dir()</code>获取对象的所有属性，实际上<code>len()</code>方法是自动调用该对象的<code>__len__()</code>方法</p>
<p>配合<code>getattr()</code>、<code>setattr()</code>以及<code>hasattr()</code>，我们可以直接操作一个对象的状态:</p>
<pre><code>&gt;&gt;&gt; class MyObject(object):
...     def __init__(self):
...         self.x = 9
...     def power(self):
...         return self.x * self.x
...
&gt;&gt;&gt; obj = MyObject()

&gt;&gt;&gt; hasattr(obj, &apos;x&apos;) # 有属性&apos;x&apos;吗？
True
&gt;&gt;&gt; obj.x
9
&gt;&gt;&gt; hasattr(obj, &apos;y&apos;) # 有属性&apos;y&apos;吗？
False
&gt;&gt;&gt; setattr(obj, &apos;y&apos;, 19) # 设置一个属性&apos;y&apos;
&gt;&gt;&gt; hasattr(obj, &apos;y&apos;) # 有属性&apos;y&apos;吗？
True
&gt;&gt;&gt; getattr(obj, &apos;y&apos;) # 获取属性&apos;y&apos;
19
&gt;&gt;&gt; obj.y # 获取属性&apos;y&apos;
19
</code></pre><h3 id="实例属性和类属性"><a href="#实例属性和类属性" class="headerlink" title="实例属性和类属性"></a>实例属性和类属性</h3><p>不可对实例属性和类属性使用相同的名字，因为相同名称的实例属性将屏蔽掉类属性，但是当你删除实例属性后，再使用相同的名称，访问到的将是类属性。</p>
<pre><code>&gt;&gt;&gt; class Student(object):
...     name = &apos;Student&apos;
...
&gt;&gt;&gt; s = Student() # 创建实例s
&gt;&gt;&gt; print(s.name) # 打印name属性，因为实例并没有name属性，所以会继续查找class的name属性
Student
&gt;&gt;&gt; print(Student.name) # 打印类的name属性
Student
&gt;&gt;&gt; s.name = &apos;Michael&apos; # 给实例绑定name属性
&gt;&gt;&gt; print(s.name) # 由于实例属性优先级比类属性高，因此，它会屏蔽掉类的name属性
Michael
&gt;&gt;&gt; print(Student.name) # 但是类属性并未消失，用Student.name仍然可以访问
Student
&gt;&gt;&gt; del s.name # 如果删除实例的name属性
&gt;&gt;&gt; print(s.name) # 再次调用s.name，由于实例的name属性没有找到，类的name属性就显示出来了
Student
</code></pre><p>给Student类增加一个类属性，每创建一个实例，该属性自动增加：</p>
<pre><code>class Student(object):
    count = 0

    def __init__(self, name):
        self.name = name
        Student.count += 1 # 访问类属性
</code></pre><p>变量的类型：</p>
<ol>
<li>全局变量 - 在所有函数和类的外面</li>
<li>局部变量 -  <ol>
<li>在函数内</li>
<li>在class的方法内，未加 self 修饰</li>
</ol>
</li>
<li>静态变量 - 在class内，并且是在方法外</li>
<li>实例变量 - 在class方法内，用self修饰</li>
</ol>
<h2 id="面向对象高级编程"><a href="#面向对象高级编程" class="headerlink" title="面向对象高级编程"></a>面向对象高级编程</h2><p>给实例绑定一个属性：</p>
<pre><code>class Student(object):
    pass

&gt;&gt;&gt; s = Student()
&gt;&gt;&gt; s.name = &apos;Michael&apos; # 动态给实例绑定一个属性
&gt;&gt;&gt; print(s.name)
Michael
</code></pre><p>给实例绑定一个方法：</p>
<pre><code>&gt;&gt;&gt; def set_age(self, age): # 定义一个函数作为实例方法
...     self.age = age
...
&gt;&gt;&gt; from types import MethodType
&gt;&gt;&gt; s.set_age = MethodType(set_age, s) # 给实例绑定一个方法
&gt;&gt;&gt; s.set_age(25) # 调用实例方法
&gt;&gt;&gt; s.age # 测试结果
25
</code></pre><p>给类绑定一个方法：</p>
<pre><code>&gt;&gt;&gt; def set_score(self, score):
...     self.score = score
...
&gt;&gt;&gt; Student.set_score = set_scor
</code></pre><p>使用<code>__slots__</code>可以限制实例的属性,使用<strong>slots</strong>要注意，<strong>slots</strong>定义的属性仅对当前类实例起作用，对继承的子类是不起作用的。</p>
<pre><code>class Student(object):
    __slots__ = (&apos;name&apos;, &apos;age&apos;) # 用tuple定义允许绑定的属性名称
</code></pre><p><code>@property</code>装饰器就是负责把一个方法变成属性调用的:</p>
<pre><code>class Student(object):

    @property
    def score(self):
        return self._score

    @score.setter
    def score(self, value):
        if not isinstance(value, int):
            raise ValueError(&apos;score must be an integer!&apos;)
        if value &lt; 0 or value &gt; 100:
            raise ValueError(&apos;score must between 0 ~ 100!&apos;)
        self._score = value

&gt;&gt;&gt; s = Student()
&gt;&gt;&gt; s.score = 60 # OK，实际转化为s.set_score(60)
&gt;&gt;&gt; s.score # OK，实际转化为s.get_score()
60
&gt;&gt;&gt; s.score = 9999
Traceback (most recent call last):
...
ValueError: score must between 0 ~ 100!
</code></pre><p>注意：<code>@property</code> 赋值时需要使用<code>_xx</code></p>
<h3 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h3><p>Mixln：在设计类的继承关系时，通常主线都是翻译继承下来的，但是如果需要“混入”额外的功能，通过多重继承可以实现。这种设计模式通常称为Mixln。Mixln的目的就是给一个类增加多个功能。</p>
<p>tips：多重继承中的属性或者方法重复，遵循取左原则</p>
<pre><code>class A(object):

    def __init__(self):
        self.name = &apos;A&apos;

class B(object):

    def __init__(self):
        self.name = &apos;B&apos;

class C(A, B):
    pass

class D(B, A):
    pass

a = C()
print(a.name)
b = D()
print(b.name)

A
B
</code></pre><p>python继承的优先顺序：按照拓扑排序：</p>
<p>在图论中，拓扑排序(Topological Sorting) 是一个 有向无环图(DAG,Directed Acyclic Graph) 的所有顶点的线性序列。且该序列必须满足下面两个条件：</p>
<ul>
<li>每个顶点出现且只出现一次。</li>
<li>若存在一条从顶点A到B的路径，那么序列中顶点A在B的前面。<img src="/2019/06/08/python基础知识复习/DAG.jpg" title="Topological Sorting">
</li>
</ul>
<p>它是一个DAG图，那么如何写出它的拓扑顺序呢？这里说一种比较常用的方法：</p>
<ul>
<li>从DAG途中选择一个没有前驱(即没有指向其的箭头)的顶点并输出。</li>
<li>从图中删除该顶点和所有以它为起点的有向边。</li>
<li>重复1和2直到当前DAG图为空或当前途中不存在无前驱的顶点为止。后一种情况说明有向图中必然存在环。<img src="/2019/06/08/python基础知识复习/topo_sorted.webp" title="Topo_sorted">
</li>
</ul>
<p>python C3算法遍历DAG顺序寻找方法，优先找到即调用。</p>
<h2 id="定制类"><a href="#定制类" class="headerlink" title="定制类"></a>定制类</h2><p><code>__str__()</code>存储了实例的字符串：</p>
<pre><code>class Student(object):
    count = 0

    def __init__(self, name):
        self.name = name
        Student.count += 1 # 访问类属性

    def __str__(self):
        return &apos;Student object (name: %s)&apos; % self.name

print(Student(&apos;wdji&apos;))

Student object (name: wdji)
</code></pre><p>直接显示调用的变量还是不好看：</p>
<pre><code>&gt;&gt;&gt; s = Student(&apos;Michael&apos;)
&gt;&gt;&gt; s
&lt;__main__.Student object at 0x109afb310&gt;
</code></pre><p>因为直接显示变量调用的不是<code>__str__()</code>，而是<code>__repr__()</code>，两者的区别是<code>__str__()</code>返回用户看到的字符串，而<code>__repr__()</code>返回程序开发者看到的字符串，也就是说，<code>__repr__()</code>是为调试服务的。</p>
<pre><code>class Student(object):
    count = 0

    def __init__(self, name):
        self.name = name
        Student.count += 1 # 访问类属性

    def __str__(self):
        return &apos;Student object (name: %s)&apos; % self.name

    __repr__ == __str__
</code></pre><p><code>__iter__()</code>一个类想被<code>for ... in</code>循环，类似list，tuple就必须实现一个<code>__iter__()</code>方法，该方法返回一个迭代对象。</p>
<pre><code>class Fib(object):

    def __init__(self):
        self.a, self.b = 0, 1

    def __iter__(self):
        return self

    def __next__(self):
        self.a , self.b = self.b, self.a + self.b
        if self.a &gt; 1000:
            raise StopIteration()
        return self.a

for n in Fib():
    print(n)

1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987
</code></pre><p><code>__getitem__()</code>:实现像list一样取出按照下表取出元素</p>
<pre><code>class Fib(object):

    def __getitem__(self, n):
        a, b = 1, 1
        for x in range(n):
            a, b = b, a + b
        return a

f = Fib()
print(f[5]) # 8
</code></pre><p>实现切片需要判断n的类型：</p>
<pre><code>class Fib(object):

    def __getitem__(self, n):
        if isinstance(n, int):
            a, b = 1, 1
            for _ in range(n):
                a, b = b, a + b
            return a
        if isinstance(n, slice):
            start = n.start
            stop = n.stop
            if start is None:
                start = 0
            a, b = 1, 1
            L = []
            for x in range(stop):
                if x &gt;= start:
                    L.append(a)
                a, b = b, a + b
            return L

f = Fib()
print(f[5:10]) # [8, 13, 21, 34, 55]
</code></pre><p>以上没有处理step和负数，所以实现一个<code>__getitem__()</code>还有很多工作要做。如果把对象看成dict，<code>__getitem__()</code>的参数也可能是一个可以作key的object，例如str。</p>
<p>与之对应的是<code>__setitem__()</code>方法，把对象视作list或dict来对集合赋值。最后，还有一个<code>__delitem__()</code>方法，用于删除某个元素。通过上面的方法，我们自己定义的类表现得和Python自带的list、tuple、dict没什么区别，这完全归功于动态语言的“鸭子类型”，不需要强制继承某个接口。</p>
<p><code>__getattr__()</code></p>
<p>调用不存在的属性时会报错，可以用<code>__getattr__()</code>实现动态的返回一个属性。</p>
<pre><code>class Student(object):
    count = 0

    def __init__(self, name):
        self.name = name
        Student.count += 1 # 访问类属性

    def __str__(self):
        return &apos;Student object (name: %s)&apos; % self.name

    def __getattr__(self, attr):
        if attr == &apos;age&apos;:
            return lambda: 25
        raise AttributeError(&apos;\&apos;Student\&apos; object has no attribute \&apos;%s\&apos;&apos; % attr)

print(Student(&apos;wdji&apos;))
a = Student(&apos;wdji2&apos;)
print(a.age()) # 25
print(a.grade) # AttributeError: &apos;Student&apos; object has no attribute &apos;grade&apos;
</code></pre><p>动态调用的特性可以用在网站的REST API；利用完全动态的<code>__getattr__()</code>写出一个链式调用。</p>
<pre><code>class Chain(object):

    def __init__(self, path=&apos;&apos;):
        self._path = path

    def __getattr__(self, path):
        return Chain(&apos;%s/%s&apos; % (self._path, path))

    def __str__(self):
        return self._path

    __repr__ = __str__
</code></pre><p><code>__call__()</code></p>
<p>定义一个<strong>call</strong>()方法，就可以直接对实例进行调用:</p>
<pre><code>class Student(object):
    def __init__(self, name):
        self.name = name

    def __call__(self):
        print(&apos;My name is %s.&apos; % self.name)

&gt;&gt;&gt; s = Student(&apos;Michael&apos;)
&gt;&gt;&gt; s() # self参数不要传入
My name is Michael.
</code></pre><p><code>__call__()</code>还可以定义参数。<strong>对实例进行直接调用就好比对一个函数进行调用一样，所以你完全可以把对象看成函数，把函数看成对象，因为这两者之间本来就没啥根本的区别。如果你把对象看成函数，那么函数本身其实也可以在运行期动态创建出来，因为类的实例都是运行期创建出来的，这么一来，我们就模糊了对象和函数的界限</strong>。</p>
<p>那么，怎么判断一个变量是对象还是函数呢？其实，更多的时候，我们需要判断一个对象是否能被调用，能被调用的对象就是一个Callable对象，比如函数和我们上面定义的带有<strong>call</strong>()的类实例：</p>
<pre><code>&gt;&gt;&gt; callable(Student())
True
&gt;&gt;&gt; callable(max)
True
&gt;&gt;&gt; callable([1, 2, 3])
False
&gt;&gt;&gt; callable(None)
False
&gt;&gt;&gt; callable(&apos;str&apos;)
False

class urls(Chain):
    def __init__(self, path=&apos;/users&apos;):
    self.__path = path

    def __getattr__(self, path):
        return urls((&apos;%s/%s&apos; % (self.__path, path)))

    def __call__(self, path):
        return urls((&apos;%s/%s&apos; % (self.__path, path)))

    def __str__(self):
        return self.__path

    __repr__ = __str__
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/27/network_learning/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Weidong Ji">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PrueMat">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/27/network_learning/" itemprop="url">计算机网络学习笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-27T22:42:27+08:00">
                2019-05-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="第七章-网络互连"><a href="#第七章-网络互连" class="headerlink" title="第七章 网络互连"></a>第七章 网络互连</h2><p>···</p>
<p><strong>因特网际协议IP</strong><br>7.24 ip数据报格式：<br><img src="/2019/05/27/network_learning/ip.png" title="ip报文"></p>
<p>首部不可变部分：</p>
<ol>
<li>版本：占4bit，指IP协议的版本。通信双方使用的IP协议的版本必须一致。目前广泛使用的IP协议版本号为4 (即IPv4)</li>
<li>首部长度：可表示的最大数值是15个单位(一个单位为4字节)，因此IP的首部长度的最大值是60字节。当IP分组的首部长度不是4字节的整数倍时，必须利用最后一个填充字段加以填充。因此数据部分永远在4字节的整数倍时开始，这样在实现IP协议时较为方便。首部长度限制为60字节的缺点是有时(如源站路由选择)不够用。但这样做是希望用户尽量减少开销。最常用的首部长度就是20字节，即不使用任何选项。</li>
<li>服务类型：<ul>
<li>前3个比特表示优先级，它可使数据报具有8个优先级中的一个。</li>
<li>第4个比特是D比特，表示要求有更低的时延。</li>
<li>第5个比特是T比特，表示要求有更高的吞吐量。</li>
<li>第6个比特是R比特，表示要求有更高的可靠性(即在数据报传送的过程中，被路由器丢弃的概率要更小些)。</li>
<li>第7个比特是C比特，是新增加的，表示要求选择费用更低廉的路由。</li>
<li>最后一个比特目前尚未使用</li>
</ul>
</li>
<li>总长度：总长度指首部和数据之和的长度，单位为字节。总长度字段为16 bit，因此数据报的最大长度为65535字节(即64 KB)。<br>在IP层下面的每一种数据链路层都有其自己的帧格式，其中包括数据字段的最大长度，这在IP层中就称为最大传送单元MTU (Maximum Transfer Unit)。当一个IP数据报封装成链路层的帧时，此数据报的总长度(即首部加上数据部分)一定不能超过MTU的值。表7-3给出了不同链路层协议的MTU值。<img src="/2019/05/27/network_learning/MTU.png" title="MTU">
虽然使用尽可能长的数据报会使传输效率提高，但由于以太网的普遍应用，实际上使用的数据报长度很少有超过1500字节的，而有时数据报长度还被限制在576字节。当数据报长度超过网络所容许的最大传送单元MTU时，就必须将过长的数据报进行分片后才能在网络上传送。这时，数据报首部中的“总长度”字段不是指未分片前的数据报长度，而是指分片后每片的首部长度与数据长度的总和。</li>
<li>标识：当数据过长需要分片时，各分片中的标识计数器用于重新组装数据。</li>
<li>标志：占3bit。<ul>
<li>最低为记为MF，MF=1表示后面还有分片的数据报；MF=0，表示这是若干数据报中的最后一个。</li>
<li>中间一位记为DF，意思是不能分片，当其为0时允许分片</li>
</ul>
</li>
<li>片位移：较长的分组在分片后，某片在原分组中的相对位置。也就是说，相对于用户数据字段的起点，该片从何处开始。片偏移以8个字节为偏移单位。片偏移等于5就表明偏移量为40字节。每个分片的长度一定是8字节(64 bit)的整数倍。</li>
<li>生存时间：生存时间字段记为TTL(Time To Live)，即数据报在网络中的寿命。一个数据报在它通过互连网时必须具有受限的寿命。这个字段用来控制数据报所通过路由器的最大跳数。当源站发送数据报时，它在此字段写入一个数。这个数值约为任何两个主机之间的路由器数的两倍。当路由器收到一个数据报时，它先将此字段的值减1。若在减1之后此字段的值是0，路由器就丢弃该数据报。</li>
<li>协议：占8 bit，协议字段指出此数据报携带的数据是使用何种协议，以便使目的主机的IP层知道应将此数据报上交给哪个进程。图7-15表示IP层需要根据这个协议字段的值将所收到的数据交付到正确地方。常用的一些协议和相应的协议字段值如下：<img src="/2019/05/27/network_learning/ip_protocol.png" title="ip_protocol"></li>
<li>首部检验和：此字段只检验数据报的首部，不包括数据部分。这是因为数据报每经过一个结点，结点处理机就要重新计算一下首部检验和(一些字段，如生存时间、标志、片偏移等都可能发生变化)。检验和不采用CRC检验码而采用下面的简单计算方法：在发送端，先将IP数据报首部划分为许多16 bit字的序列，并将检验和字段置零。用反码算术运算将所有16 bit字相加后，将得到的和的反码写入检验和字段。接收端收到数据报后，将首部的所有16 bit字再使用反码算术运算相加一次。将得到的和取反码，即得出接收端检验和的计算结果。若首部未发生任何变化，则此结果必为0，于是就保留这个数据报。否则即认为出差错，并将此数据报丢弃</li>
<li>源地址：占4字节。这是首部中最重要的字段。</li>
<li>目的地址：占4字节。这也是首部中最重要的字段。</li>
</ol>
<p>首部可变部分：1-40字节</p>
<ul>
<li>源站路由选择，通常不使用<ul>
<li>严格源站路由选择：不允许修改源站事先规定好的路由。</li>
<li>不严格源站路由选择：允许修改源站事先规定好的路由。</li>
</ul>
</li>
<li>因特网时间戳：记录路由器收到数据报的时间戳，用于统计数据报经路由器产生的时延和时延变化。</li>
</ul>
<p><strong>ip层处理数据报的过程</strong><br>路由表：<strong>目的网络地址，下一跳地址</strong><br>可以使用默认路由，<br>具体转发过程如下：</p>
<ol>
<li>从数据报的首部提取目的站的IP地址D，得出目的网络地址为N。</li>
<li>若N是就与此路由器直接相连的某个网络地址，则这种交付为直接交付，即不需要再经过其他的路由器。这时就直接通过该网络将数据报交付给目的站D (这里包括将目的主机地址D转换为具体的硬件地址，将数据报封装为MAC帧，再发送此帧)；否则就是间接交付，执行（3）。</li>
<li>若路由表中有目的地址为D的指明主机路由，则将数据报传送给路由表中所指明的下一跳路由器；否则，执行（4）。</li>
<li>若路由表中有到达网络N的路由，则将数据报传送给路由表中所指明的下一跳路由器；否则，执行（5）。</li>
<li>若路由表中有一个默认路由，则将数据报传送给路由表中所指明的默认路由器；否则，执行（6）。</li>
<li>报告转发分组出错。</li>
</ol>
<p><strong>子网划分</strong>：子网掩码，寻址时目的网络与子网掩码相与（都是1则返回1，否则返回0），是否等于网络号，若相等则是下一跳地址。</p>
<p><strong>无分类编址</strong>：无分类编址CIDR：ip后指定网络号的比特数。仍然使用掩码。</p>
<p><strong>最长匹配原则</strong>：因为网络前缀越长，其地址块就越小，因而路由就越具体(more specific)。</p>
<p>7.4 <strong>因特网控制报文协议ICMP(Internet Control Message Protocol)</strong><br>为了提高IP数据报交付成功的机会，ICMP允许主机或路由器报告差错情况和提供有关异常情况的报告。但ICMP不是高层协议，而是IP层的协议。ICMP报文作为IP层数据报的数据，加上数据报的首部，组成数据报发送出去。</p>
<p>ICMP报文格式：<br><img src="/2019/05/27/network_learning/ICMP.png" title="ICMP"><br>ICMP报文的种类有两种，即ICMP差错报告报文和ICMP询问报文。<br>ICMP报文的前4个字节是统一的格式，共有三个字段：即类型、代码和检验和。接着的4个字节的内容与ICMP的类型有关。再后面是数据字段，其长度取决于ICMP 的类型。ICMP报文的类型字段的值与ICMP报文类型的对应关系如表7-7所示。<br><img src="/2019/05/27/network_learning/ICMP1.png" title="ICMP"></p>
<p>7.5<strong>路由选择算法</strong><br>1.理想的路由算法<br>特点：</p>
<ol>
<li>算法必须是正确的和完整的。这里，“正确”的含义是：沿着各路由表所指引的路由，分组一定能够最终到达的目的网络和目的主机。</li>
<li>算法在计算上应简单。进行路由选择的计算必然要增加分组的时延。因此，路由选择的计算不应使网络通信量增加太多的外开销。当为了计算合适的路由而必须使用网络其他路由器发来的大量状态信息时，就会使网络通信量的开销过大。</li>
<li>算法应能适应通信量和网络拓扑的变化，这就是说，要有自适应性。当网络中的通信量发生变化时，算法能自适应地改变路由以均衡各链路的负载。当某个或某些结点、链路发生故障不能工作，或者修理好了再投入运行时，算法也能及时地改变路由。有时称这种自适应性为“稳健性”(robustness)①。</li>
<li>算法应具有稳定性。在网络通信量和网络拓扑相对稳定的情况下，路由算法应收敛于一个可以接受的解，而不应使得出的路由不停地变化。</li>
<li>算法应是公平的。这就是说，算法应对所有用户(除对少数优先级高的用户)都是平等的。例如，若使某一对用户的端到端时延为最小，但不考虑其他的广大用户，这就明显地不符合公平性的要求。</li>
<li>算法应是最佳的。这里的“最佳”是指以最低的代价来实现路由算法。这里特别需要注意的是，在研究路由选择时，需要给每一条链路指明一定的费用(cost)(也可以将cost译为“代价”)，而这里“费用”并不是指“钱”，而是由一个或几个因素综合决定的一种度量(metric)，如链路长度、数据率、链路容量、是否要保密、传播时延等，甚至还可以是一天中某一个小时内的通信量、结点的缓存被占用的程度、链路差错率等。可以根据用户的具体情况来设置每一条链路的“费用”。由此可见，不存在一种绝对的最佳路由算法。所谓“最佳”只能是相对于某一种特定要求下得出的较为合理的选择而已。</li>
</ol>
<p>从路由算法能否随网络的通信量或拓扑自适应地进行调整变化来划分，则只有两大类，即<strong>静态路由选择策略</strong>与<strong>动态路由选择策略</strong>。静态路由选择也叫做非自适应路由选择，其特点是简单和开销较小，但不能及时适应网络状态的变化。动态路由选择也称为自适应路由选择，其特点是能较好地适应网络状态的变化，但实现起来较为复杂，开销也比较大。</p>
<p>2.分层次的路由选择协议</p>
<p>由于以下两个原因，因特网采用分层次的路由选择协议：<br>（1）因特网的规模非常大，现在就已经有几百万个路由器互连在一起。如果让所有的路由器知道所有<br>的网络应怎样到达，则这种路由表将非常大，处理起来也太花时间。而所有这些路由器之间交换路由信息<br>所需的带宽就会使因特网的通信链路饱和。<br>（2）许多单位不愿意外界了解自己单位网络的布局细节和本单位所采用的路由选择协议(这属于本单位<br>内部的事情)，但同时还希望连接到因特网上。<br>为此，因特网将整个互联网划分为许多较小的自治系统(autonomous system</p>
<p>两大类路由选择协议：</p>
<ul>
<li>内部网关协议IGP (Interior Gateway Protocol)。这是在一个自治系统内部使用的路由选择协议，而<br>这与在互联网中的其他自治系统选用什么路由选择协议无关。目前这类路由选择协议使用得最多，如RIP<br>和OSPF协议。</li>
<li>外部网关协议EGP (External Gateway Protocol)。若源站和目的站处在不同的自治系统中(这两个自<br>治系统使用不同的内部网关协议)，当数据报传到一个自治系统的边界时，就需要使用一种协议将路由选择<br>信息传递到另一个自治系统中。这样的协议就是外部网关协议EGP。在外部网关协议中目前使用最多的是BGP</li>
</ul>
<p>7.5.2</p>
<p>路由信息协议RIP (Routing Information Protocol)是内部网关协议IGP中使用得最广泛的一个[RFC 1058]。RIP是一种分布式的基于距离向量的路由选择协议，是因特网的标准协议，其最大优点就是简单。</p>
<p>RIP协议要求网络中的每一个路由器都要维护从它自己到其他每一个目的网络的距离记录(因此，这是一组距离，即“距离向量”)。RIP协议将“距离”定义如下：<br>从一路由器到直接连接的网络的距离定义为1。从一路由器到非直接连接的网络的距离定义为所经过的路由器数加1。“加1”是因为到达目的网络后就进行直接交付，而到直接连接的网络的距离已经定义为1。例如在前面讲过的图7-16中，路由器R1到网1或网2的距离都是1(直接连接)，而到网3的距离是2，到网4的距离是3。<br>RIP协议的“距离”也称为“跳数”(hop count)①，因为每经过一个路由器，跳数就加1。RIP认为一个好的路由就是它通过的路由器的数目少，即“距离短”。RIP允许一条路径最多只能包含15个路由器。因此“距离”的最大值为16时即相当于不可达。可见RIP只适用于小型互联网。</p>
<p>需要注意的是，到直接连接的网络的距离也可定义为0(采用这种定义的理由是：路由器在和直接连接在该网络上的主机通信时不需要经过另外的路由器。既然每经过一个路由器要将距离加1，那么不再经过路由器的距离就应当为零)。作者编写的其他版本的教材过去也曾使用过这种定义。但两种不同的定义对实现RIP协议并无影响，因为重要的是要找出最短距离，将所有的距离都加1或减1对选择最佳路由都是一样的。<br>RIP不能在两个网络之间同时使用多条路由。RIP选择一个具有最少路由器的路由(即最短路由)，哪怕还存在另一条高速(低时延)但路由器较多的路由。</p>
<p>RIP协议使用运输层的用户数据报UDP进行传送。因此RIP协议的位置应当在应用层。但转发IP数据报的过程是在网络层完成的。</p>
<p>好消息传播得快，而坏消息传播得慢。网络出故障的传播时间往往需要较长的时间(例如数分钟)。这是RIP的一个主要缺点。</p>
<p>7.5.3</p>
<p><strong>OSPF</strong>的三个要点（对比RIP）：</p>
<ol>
<li>向本自制系统内所有路由器发送信息，使用洪泛法：通过输出端口向所有连接的路由器发送信息，相邻路由器将此消息发送给其相邻的所有路由器。</li>
<li>发送的信息是<em>本路由器与相邻的所有路由器的链路状态</em></li>
<li>只有当链路状态发生变化时才使用洪泛法发送信息，<strong>收敛速度极快</strong>。</li>
</ol>
<p>特点：OSPF所有路由器最终建立一个链路状态数据库，实际就是<strong>全网的拓扑结构</strong>,RIP只知道所有网络的距离以及吓一跳的路由器，却不知道全网的拓扑结构。</p>
<p>应用：为了使OSPF能够应用于规模较大的网络，可以将一个自治系统划分为若干个区域（小范围），每个区域有一个32bit的<strong>区域标志符</strong>，好处是：就是将利用洪泛法交换链路状态信息的范围局限于每一个区域而不是整个的自治系统。因此，在一个区域内部的路由器只知道本区域的完整网络拓扑，而不知道其他区域的网络拓扑的情况。为了使每一个区域能够和本区域以外的区域进行通信，OSPF使用层次结构的区域划分。在上层的区域叫做主干区域(backbone area)。主干区域的标识符规定为0.0.0.0。主干区域的作用是用来连通其他在下层的区域。从其他区域来的信息都由区域边界路由器(area border router)进行概括。主干区域还要有一个路由器与其他自治系统交换路由器信息叫做<strong>自治系统边界路由器</strong>.</p>
<p>采用分层次划分区域的优点：虽然是交换信息的种类增加了，同时也使OSPF协议更加复杂，但是使的每一个区域内部交换路由的信息量大大减小。使OSPF能够用于很大规模的自治系统。</p>
<p>OSPF位于网络层，使用IP数据报传送，其数据报很短可以减少路由信息的通信量。</p>
<h2 id="第八章-运输层"><a href="#第八章-运输层" class="headerlink" title="第八章 运输层"></a>第八章 运输层</h2>
<p><strong>分用</strong>就是将运输层报文段中的数据交付到正确的套接字的工作</p>
<p><strong>复用</strong>就是在源主机从不同套接字中收集数据块，并为每个数据块封装上首部信息，从而生成报文段，然后将报文段传递到网络层的工作。</p>
<h3 id="运输层功能"><a href="#运输层功能" class="headerlink" title="运输层功能"></a>运输层功能</h3><ul>
<li>运输层为应用进程之间提供逻辑通信，网络层为主机间提供逻辑通信。</li>
<li>运输层还要对收到的报文进行差错检测。大家应当还记得，在网络层，IP数据报首部中的检验和字段，只检验首部是否出现差错而不检查数据部分。</li>
</ul>
<h3 id="TCP-IP体系中的运输层"><a href="#TCP-IP体系中的运输层" class="headerlink" title="TCP/IP体系中的运输层"></a>TCP/IP体系中的运输层</h3><p>运输层的2个协议<br><img src="/2019/05/27/network_learning/tcp_udp.png" title="tcp and udp"></p>
<p>端口的概念</p>
<p>16bit的地址，最大可允许有64k个端口号</p>
<p>没有端口，运输层就无法知道数据应当交付给应用层的哪一个进程。从这个意义上讲，端口是用来标识应用层的进程。由于使用了复用和分用技术，在运输层与网络层的交互中已看不见各种应用进程，而只有TCP报文段或用户数据报。IP层也使用类似的复用和分用技术，因而在网络层和链路层的交互中也只有IP数据报。上述概念在网络中是十分重要的。</p>
<p>TCP以<strong>连接</strong>作为最基本的抽象，一个连接由它的两个端点来标志，这样的端点叫做<strong>插口（socket）</strong>或者<strong>套接字</strong>，插口包括IP和端口号，共48bit。</p>
<p>UDP的优点：</p>
<ol>
<li>发送数据前不需要建立连接，减少了发送数据之前的延迟。</li>
<li>UDP没有拥塞控制，也不保证可靠交付，因此主机不需要维持具有许多参数的，复杂的连接状态表。</li>
<li>UDP用户数据报首部只有八个字节开销，比TCP的20个要少。</li>
<li>UDP适合允许适当丢包但实时性要求较高的数据传输。</li>
</ol>
<p>使用UDP的应用<br><img src="/2019/05/27/network_learning/udp-protocal.png" title="udp-protocal"></p>
<p>UDP的缺点：</p>
<ol>
<li>使用没有拥塞控制的UDP，但当很多的源主机同时都向网络发送高速率的实时视频流时，网络就有可能发生拥塞，结果大家都无法正常接收。因此“UDP不具有拥塞控制功能”，可能会引起网络产生严重的拥塞问题。</li>
<li>IP层将收到的IP数据报的数据部分上交给UDP。UDP再对收到的用户数据报进行分用，按照端口号将其加入到相应队列的末尾。如果队列已满，就丢弃该用户数据报。这里没有流量控制机制来通知发送方来降低发送速率。当应用进程要接收报文时，就从相应的队列前头取走一个报文。若队列已空，应用进程就被阻塞，直到队列中有到达的报文为止。</li>
</ol>
<p>UDP 数据报格式</p>
<h3 id="TCP报文段"><a href="#TCP报文段" class="headerlink" title="TCP报文段"></a>TCP报文段</h3><img src="/2019/05/27/network_learning/TCP报文首部.png" title="TCP报文首部">
<ol>
<li>源端口和目的端口：16bit的端口和IP构成socket。</li>
<li>序号：占四个字节，TCP是面向数据流的，TCP传送的保温可以看作是连续的数据流。其中每一个字节都对应一个序号。“首部的徐浩是指本报问的所发送的数据中的第一个字节的序号。例如，某报文段的序号字段的值是301，而携带的数据共100字节，则本报文段的数据的第一个字节的序号是301，而最后一个字节的序号是400。这样，下一个报文段的数据序号应当从401开始，因而下一个报文段的序号字段的值应为401。</li>
<li>确认序号：占四个字节，是期望收到对方的下一个报文段的数据的第一个字节的序号，也就是期望收到的下一个报文段首部的序号字段的值。例如，正确收到了一个报文段，其序号字段的值是501，而数据长度是200字节，这就表明序号在501 ~ 700之间的数据均已正确收到。因此在响应的报文段中应将确认序号置为701。请注意：确认序号既不是501也不是700。 由于序号字段有32 bit长，可对4 GB(即4千兆字节)的数据进行编号。这样就可保证当序号重复使用时，旧序号的数据早已在网络中消失了。</li>
<li>数据偏移，它指出数据开始的地方离TCP报文段的起始处有多远。<strong>就是指出数据部分从什么地方开始</strong>。</li>
<li>保留，保留字段没有使用。</li>
<li>控制比特：<ul>
<li>紧急比特：URG = 1标识此报文是紧急比特（优先级高），应当尽快传送。如ctrl+C中断命令</li>
<li>确认ACK，ACK=1时，确认序号字段才有用。为0时确认序号无效。</li>
<li>推送比特：当两个应用进程进行交互式的通信时，有时在一端的应用进程希望在键入一个命令后立即就能够收到对方的响应。在这种情况下，TCP就可以使用推送(push)操作。这时，发送端TCP将推送比特PSH置1，并立即创建一个报文段发送出去。接收TCP收到推送比特置1的报文段，就尽快(即“推送”向前)交付给接收应用进程，而不再等到整个缓存都填满了后再向上交付。PSH比特也可叫做急迫比特。 虽然应用程序可以选择推送操作，但推送操作还是往往不被人们使用。TCP可以选择或不选择这个操作。</li>
<li>复位比特RST (ReSeT) 当RST = 1时，表明TCP连接中出现严重差错(如由于主机崩溃或其他原因)，必须释放连接，然后再重新建立运输连接。复位比特还用来拒绝一个非法的报文段或拒绝打开一个连接。复位比特也可称为重建比特或重置比特。</li>
<li>同步比特SYN 在连接建立时用来同步序号。当SYN = 1而ACK = 0时，表明这是一个连接请求报文段。对方若同意建立连接，则应在响应的报文段中使SYN = 1和ACK = 1。因此，同步比特SYN置为1，就表示这是一个连接请求或连接接受报文。关于连接的建立和释放，后面还要进行讨论。</li>
<li>终止比特FIN (FINal) 用来释放一个连接。当FIN = 1时，表明此报文段的发送端的数据已发送完毕，并要求释放运输连接。</li>
</ul>
</li>
<li>窗口：占2字节。窗口字段用来控制对方发送的数据量，单位为字节。用接收端的接收能力的大小来控制发送端的数据发送量。</li>
<li>检验和:检验首部和数据部分的正确性。</li>
<li>选项：长度可变。TCP只规定了一种选项，即最大报文段长度MSS (Maximum Segment Size)。MSS告诉对方TCP：“我的缓存所能接收的报文段的数据字段的最大长度是MSS。”当没有选项时，TCP的首部长度是20字节。</li>
</ol>
<h3 id="TCP的数据编号和确认"><a href="#TCP的数据编号和确认" class="headerlink" title="TCP的数据编号和确认"></a>TCP的数据编号和确认</h3><p>TCP协议是面向字节的。TCP将所要传送的整个报文(这可能包括许多个报文段)看成是<strong>一个个字节组成的数据流</strong>，并<strong>使每一个字节对应于一个序号</strong>。在连接建立时，双方要商定初始序号。TCP每次所发送的报文段的首部中的序号字段数值表示该报文段中的数据部分的<strong>第一个字节的序号</strong>。TCP的确认是对<strong>接收到的数据的最高序号</strong>(即收到的数据流中的最后一个序号)<strong>表示确认</strong>。但接收端返回的确认序号是已收到的数据的最高序号加1。也就是说，<strong>确认序号表示接收端期望下次收到的数据中的第一个数据字节的序号。</strong></p>
<p>TCP发送数据的时机</p>
<ol>
<li>维持一个变量，值等于MSS，发送缓存中得到的数据达到MSS就发送出去。</li>
<li>PUSH指定的报文段。</li>
<li>发送端设置计时器，时间到了就把缓存中的数据发送出去。</li>
</ol>
<p>实际使用Nagle算法：若发送端应用进程将欲发送的数据逐个字节地送到发送端的TCP缓存，则发送端就将第一个字符(一个字符的长度是一个字节)先发送出去，将后面到达的字符都缓存起来。当接收端收到对第一个字符的确认后，再将缓存中的所有字符装成一个报文段发送出去，同时继续对随后到达的字符进行缓存。只有在收到对前一个报文段的确认后才继续发送下一个报<br>文段。当字符到达较快而网络速率较慢时，用这样的方法可明显地减少所用的网络带宽。算法还规定，当到达的字符已达到窗口大小的一半或已达到报文段的最大长度时，就立即发送一个报文段。</p>
<img src="/2019/05/27/network_learning/TCP可变窗口流量控制.png" title="可变窗口进行流量控制举例">
<p>流量控制不仅是为了使接收端来的及接受，也为了使网络部发生拥塞。</p>
<p>发送窗口通常用：</p>
<pre><code>发送窗口 = Min [通知窗口，拥塞窗口]
</code></pre><ul>
<li>通知窗口(advertised window)是接收端根据其接收能力许诺的窗口值，是来自接收端的流量控制。接收端将通知窗口的值放在TCP报文的首部中，传送给发送端。</li>
<li>拥塞窗口(congestion window)是发送端根据网络拥塞情况得出的窗口值，是来自发送端的流量控制。</li>
</ul>
<h3 id="TCP重传机制"><a href="#TCP重传机制" class="headerlink" title="TCP重传机制"></a>TCP重传机制</h3><p>TCP每发送一个报文段，就设置一次计时器。只要计时器设置的重传时间已经到了但还没有收到确认，就要重传这一报文段。</p>
<p>TCP采用了一种自适应算法。这种算法记录每一个报文段发出的时间，以及收到相应的确认报文段的时间。这两个时间之差就是报文段的往返时延。将各个报文段的往返时延样本加权平均，就得出报文段的平均往返时延T。每测量到一个新的往返时延样本，就按下式重新计算一次平均往返时延：</p>
<h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><img src="/2019/05/27/network_learning/三次握手.png" title="三次握手">
<ol>
<li>主机A的TCP向主机B的TCP发出连接请求报文段，其首部中的同步比特SYN应置为1，同时选择一个序号x，表明在后面传送数据时的第一个数据字节的序号是x + 1。在图8-19中，一个从A到B的箭头上标有“SYN，SEQ = x”就是这个意思。</li>
<li>主机B的TCP收到连接请求报文段后，如同意，则发回确认。在确认报文段中应将SYN置为1，确认序号应为x + 1，同时也为自己选择一个序号y。</li>
<li>主机A的TCP收到此报文段后，还要向B给出确认，其确认序号为y + 1。</li>
</ol>
<p>目的： 主要是为了防止已失效的连接请求报文段突然又传送到了主机B，因而产生错误。</p>
<p>TCP释放连接：</p>
<img src="/2019/05/27/network_learning/TCP释放连接.png" title="释放连接">
<ol>
<li>TCP通知对方要释放从A到B这个方向的连接，将发往主机B的TCP报文段首部的终止比特FIN置1，其序号x等于前面已传送过的数据的最后一个字节的序号加1。</li>
<li>主机B的TCP收到释放连接通知后即发出确认，其序号为x + 1，同时通知高层应用进程，如图8-20中的箭头①所示。这样，从A到B的连接就释放了，连接处于半关闭(half-close)状态，相当于主机A向主机B说：“我已经没有数据要发送了。但你如果还发送数据，我仍接收。</li>
<li>在主机B向主机A的数据发送结束后，其应用进程就通知TCP释放连接，如图8-20中的箭头②所示。主机B发出的连接释放报文段必须将终止比特FIN置1，并使其序号y等于前面已传送过的数据的最后一个字节的序号加1，还必须重复上次已发送过的ACK = x + 1。</li>
<li>主机A必须对此发出确认，给出ACK = y + 1。这样才将从B到A的反方向连接释放掉。主机A的TCP再向其应用进程报告，整个连接已经全部释放</li>
</ol>
<h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><p>域名系统DNS (Domain Name System)：将域名转换为ip，使用udp传输</p>
<p>域名分类</p>
<p>顶级域名</p>
<ol>
<li>国家顶级域名nTLD：采用ISO 3166的规定。如：cn表示中国，us表示美国，uk表示英国，等等。</li>
<li>国际顶级域名iTLD：采用int。国际性的组织可在int下注册。</li>
<li>com表示公司企业，net表示网络服务机构，org表示非赢利性组织，edu表示教育机构，gov表示政府部门(美国专用)，mil表示军事部门(美国专用)</li>
</ol>
<p>寻址过程：递归+迭代</p>
<ol>
<li>先查询本地域名服务器（授权域名服务器），没有结果向上查根域名服务器</li>
<li>根域名服务器直接返回目标域名服务器的ip</li>
<li>查询目标域名服务器</li>
</ol>
<h3 id="FTP"><a href="#FTP" class="headerlink" title="FTP"></a>FTP</h3><p>工作原理：</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/12/jmeter/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Weidong Ji">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PrueMat">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/12/jmeter/" itemprop="url">jmeter学习记录</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-12T22:24:21+08:00">
                2019-05-12
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/学习/" itemprop="url" rel="index">
                    <span itemprop="name">学习</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/学习/性能测试/" itemprop="url" rel="index">
                    <span itemprop="name">性能测试</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="jmeter使用基础"><a href="#jmeter使用基础" class="headerlink" title="jmeter使用基础"></a>jmeter使用基础</h1><p>主页面基本介绍：<br><img src="/2019/05/12/jmeter/commonView.png" title="commonView"></p>
<h2 id="命令行执行"><a href="#命令行执行" class="headerlink" title="命令行执行"></a>命令行执行</h2><pre><code>jmeter -n -t F:\jmeter\TestPlan.jmx -l F:\jmeter\TestPlan.csv
</code></pre><h2 id="参数处理"><a href="#参数处理" class="headerlink" title="参数处理"></a>参数处理</h2><ul>
<li>手动填写</li>
<li><p>读取csv，添加CSV Data Set Config </p>
<img src="/2019/05/12/jmeter/csvSetConfig.png" title="csvConfig">
</li>
<li><p>读取文件</p>
</li>
</ul>
<h2 id="内置变量"><a href="#内置变量" class="headerlink" title="内置变量"></a>内置变量</h2><ul>
<li>日志函数：<code>${__log(“message here”)}</code></li>
<li>时间函数 time：<code>${__time(format)}</code></li>
<li>求和函数 intSum：<code>${__intSum(2,3,result)}</code> 可以调用result变量</li>
</ul>
<h2 id="selenium脚本录制"><a href="#selenium脚本录制" class="headerlink" title="selenium脚本录制"></a>selenium脚本录制</h2><ul>
<li>chrome录制依赖BlazeMeter插件，录制完成导出成jmx格式即可</li>
<li>fireFox可基于selenium+jmeter插件完成录制（适用于低版本fireFox）</li>
<li>一个支持fireFox的脚本录制插件：katalon recorder（不支持导出为jmx形式）</li>
</ul>
<h2 id="性能测试用例设计"><a href="#性能测试用例设计" class="headerlink" title="性能测试用例设计"></a>性能测试用例设计</h2><p>流程：</p>
<pre><code>线程组（用例名称），samplers, 逻辑控制器，配置元件，定时器，前置处理器，监听和断言。
</code></pre><h2 id="测试报告"><a href="#测试报告" class="headerlink" title="测试报告"></a>测试报告</h2><p>csv报告使用参数：</p>
<pre><code>-l F:\jmeter\TestPlan.csv
</code></pre><p>html报告使用参数：</p>
<pre><code>-l F:\jmeter\TestPlan.csv -e -o F:\jmeter\httpReports
</code></pre><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ul>
<li>http请求生成的csv测试报告，包括一个请求中途重定向等所有路径，csv中看到的请求数量可能是最真实的。</li>
<li>从csv读取参数时，用excel创建的csv文件无法读取参数,实际使用notepad++创建的csv文件没有问题。</li>
<li><strong>性能测试难点在于场景模拟，主要维度：</strong><ol>
<li>有思考时间：用户在不同的操作之间有时间停顿，或者延迟就是模拟用户的操作过程。</li>
<li>步伐、速度，主要是大量用户进场和退场的时间，控制迭代之间的时间。</li>
<li>压测时间</li>
<li>业务场景</li>
</ol>
</li>
<li><p>使用Aggregate Graph（聚合图像报告）抛出了如下异常，<a href="https://stackoverflow.com/questions/52755372/unable-to-display-aggregate-graph-within-jmeter" target="_blank" rel="noopener">stackoverflow</a>给出的答案是5.1版本会修复但是并没有，建议使用http report</p>
<pre><code>2019-05-11 22:30:01,456 ERROR o.a.j.JMeter: Uncaught exception: 
java.lang.ArrayIndexOutOfBoundsException: null
</code></pre></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/12/算法图解学习笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Weidong Ji">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PrueMat">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/12/算法图解学习笔记/" itemprop="url">算法图解学习笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-12T14:18:33+08:00">
                2019-05-12
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/学习/" itemprop="url" rel="index">
                    <span itemprop="name">学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="算法图解学习笔记"><a href="#算法图解学习笔记" class="headerlink" title="算法图解学习笔记"></a>算法图解学习笔记</h1><h2 id="第一章-算法简介"><a href="#第一章-算法简介" class="headerlink" title="第一章 算法简介"></a>第一章 算法简介</h2><p>二分查找：时间复杂度O(log n),</p>
<p>实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 二分法</span><br><span class="line">def binary_search(list, item):</span><br><span class="line">    low = 0</span><br><span class="line">    high = len(list)-1</span><br><span class="line"></span><br><span class="line">    while low &lt;= high:</span><br><span class="line">        mid = (low +high)//2</span><br><span class="line">        guess = list[mid]</span><br><span class="line">        if guess == item:</span><br><span class="line">            return mid</span><br><span class="line">        if guess &lt; item:</span><br><span class="line">            low = mid +1</span><br><span class="line">        else:</span><br><span class="line">            high = mid -1</span><br><span class="line">    return None</span><br></pre></td></tr></table></figure></p>
<h2 id="第二章-选择排序"><a href="#第二章-选择排序" class="headerlink" title="第二章 选择排序"></a>第二章 选择排序</h2><p>链表：顾名思义，每个元素连接着下一个元素（存储了下一个元素的位置）<br>优势：插入和删除元素方便，存储在内存中的任意位置</p>
<p>数组：所有元素存储在一起，优势在于随机读取 </p>
<p>选择排序：遍历数组找出最大或者最小的数放入新的数组中，对剩余的元素继续遍历，直到数组为空。<br>时间复杂度 O(n2)，实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 选择排序</span><br><span class="line">def selectionSorted(arr):</span><br><span class="line">    newArr = []</span><br><span class="line">    for i in range(len(arr)):</span><br><span class="line">        smallest = arr[0]</span><br><span class="line">        smallest_index = 0</span><br><span class="line">        for j in range(1,len(arr)):</span><br><span class="line">            if arr[j] &lt; smallest:</span><br><span class="line">                smallest = arr[j]</span><br><span class="line">                smallest_index = j</span><br><span class="line">        newArr.append(arr.pop(smallest_index))</span><br><span class="line"></span><br><span class="line">    return newArr</span><br></pre></td></tr></table></figure></p>
<p>冒泡排序：遍历数组，比较每个元素两两大小，将大的或小的值交换，对剩余元素继续遍历。<br>时间复杂度 O(n2)，实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 冒泡排序 </span><br><span class="line">def bubble_sorted(arr):</span><br><span class="line">    for i in range(len(arr)-1):</span><br><span class="line">        for j in range(len(arr)-i-1):</span><br><span class="line">            if arr[j] &gt; arr[j+1]:</span><br><span class="line">                temp = arr[j]</span><br><span class="line">                arr[j] = arr[j+1]</span><br><span class="line">                arr[j+1] = temp</span><br><span class="line">    return arr</span><br></pre></td></tr></table></figure></p>
<h2 id="第三章-递归"><a href="#第三章-递归" class="headerlink" title="第三章 递归"></a>第三章 递归</h2><p><strong>递归</strong>：返回时调用自己。只是在结构上更加清晰，没有性能上的优势，“如果使用循环，程序的性能可能更高；如果使用递归，程序可能更容易理解。如何选择要看什么对你来说更重要。”</p>
<p><strong>栈</strong>：一种先入后出的队列，调用栈只支持2种操作：压入（插入）和弹出（删除并读取）</p>
<h2 id="第四章-快速排序"><a href="#第四章-快速排序" class="headerlink" title="第四章 快速排序"></a>第四章 快速排序</h2><p>核心：取第一个元素作为基准值povit，其余元素与其对比，小的放入less组，大的放入glter组，返回新的数组<code>less+povit+glter</code>,对返回的数据进行同样的操作。<br>时间复杂度 O(n log n), 实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 快速排序</span><br><span class="line">def quicksort(arr):</span><br><span class="line">    if len(arr) &lt; 2:</span><br><span class="line">        return arr</span><br><span class="line">    else:</span><br><span class="line">        pivot = arr[0]</span><br><span class="line">        less = [i for i in arr[1:] if i &lt;= pivot]</span><br><span class="line">        glter = [i for i in arr[1:] if i &gt; pivot]</span><br><span class="line"></span><br><span class="line">        return quicksort(less) +[pivot] + quicksort(glter)</span><br></pre></td></tr></table></figure></p>
<p><strong>分而治之</strong>（divide and conquer，D&amp;C）：我的理解就是分成等分之后再处理。<br><strong>欧几里得算法</strong>：2个数的最大公约数，等于较小数与2者差值的最大公约数</p>
<h2 id="第五章-散列表"><a href="#第五章-散列表" class="headerlink" title="第五章 散列表"></a>第五章 散列表</h2><p>列表：</p>
<p>冲突：如果两个键映射到了同一个位置</p>
<p>解决方法：使用链表<br>影响列表速度的关键：</p>
<ol>
<li>装填因子：元素总数/位置总数，装因子越低，发生冲突的可能性越小，散列表的性能越高。一个不错的经验规则是：一旦填装因子大于0.7，就调整散列表的长度</li>
<li>良好的散列函数，良好的散列函数让数组中的值呈均匀分布。</li>
</ol>
<h2 id="第六章-广度优先搜索"><a href="#第六章-广度优先搜索" class="headerlink" title="第六章 广度优先搜索"></a>第六章 广度优先搜索</h2><p><strong>广度优先搜索</strong>：解决最短路径问题的算法。例如查找整个人际关系网查找水果经销商。主要解决2类问题：</p>
<ul>
<li>从节点A出发有到达B的路径吗？</li>
<li>从节点A到达节点B的最短路径是什么？</li>
</ul>
<p><em>队列</em>：实现广度优先搜索的顺序检查的方式；和生活中的排队一样，类似于栈只支持2中操作：<em>入队</em>和<em>出队</em>。<br>与栈的区别：</p>
<ul>
<li>队列：先进先出</li>
<li>栈：先进后出</li>
</ul>
<p><strong>图</strong>：图模拟一组连接，由节点（node）和边（edge）组成，一些名词：</p>
<ul>
<li>一度关系：节点的邻居</li>
<li>二度关系：邻居的邻居</li>
</ul>
<p>有向图：有箭头指向。<br>树：类似家谱，所有边都是向下指。</p>
<p>实现：通过dict实现，节点和邻居的关系，并实现邻居与邻居的联系<br>算法：python可以使用deque创建双端队列</p>
<p>时间复杂度 O(V + E)，其中V为顶点（vertice）数，E为边数</p>
<p>实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"># 广度优先搜索</span><br><span class="line">from collections import deque</span><br><span class="line">def person_is_seller(person): # 指定名字最后以m结尾的是经销商</span><br><span class="line">    return person[-1] == &quot;y&quot;</span><br><span class="line"></span><br><span class="line">graph = &#123;&#125; </span><br><span class="line">graph[&quot;you&quot;] = [&quot;alice&quot;, &quot;bob&quot;, &quot;claire&quot;] </span><br><span class="line">graph[&quot;bob&quot;] = [&quot;anuj&quot;, &quot;peggy&quot;] </span><br><span class="line">graph[&quot;alice&quot;] = [&quot;peggy&quot;] </span><br><span class="line">graph[&quot;claire&quot;] = [&quot;thom&quot;, &quot;jonny&quot;] </span><br><span class="line">graph[&quot;anuj&quot;] = [] </span><br><span class="line">graph[&quot;peggy&quot;] = [] </span><br><span class="line">graph[&quot;thom&quot;] = [] </span><br><span class="line">graph[&quot;jonny&quot;] = []</span><br><span class="line"></span><br><span class="line">def search(name):</span><br><span class="line">    search_queue = deque()</span><br><span class="line">    search_queue += graph[name]</span><br><span class="line">    searched = []</span><br><span class="line">    while search_queue:</span><br><span class="line">        person = search_queue.popleft()</span><br><span class="line">        if not person in searched:</span><br><span class="line">            if person_is_seller(person):</span><br><span class="line">                print(person + &apos; is a mango seller&apos;)</span><br><span class="line">                return True # return 会退出函数</span><br><span class="line">            else:</span><br><span class="line">                search_queue += graph[person]</span><br><span class="line">                searched.append(person)</span><br><span class="line">    return False</span><br></pre></td></tr></table></figure></p>
<p><em>问题</em>：同一个节点由于可能同时是多个节点的邻居可能会多次进入队列，也会出现无线循环的情况：<br>解决方法：标记节点已经检查。</p>
<h2 id="第七章-狄克斯特拉算法"><a href="#第七章-狄克斯特拉算法" class="headerlink" title="第七章 狄克斯特拉算法"></a>第七章 狄克斯特拉算法</h2><p>核心：<em>找出图中最便宜的节点，并确保没有到该节点更便宜的路径</em>。<br>适用场景：有向图，不含负加权（<strong>这是因为狄克斯特拉算法这样假设：对于处理过的海报节点，没有前往该节点的更短路径。这种假设仅在没有负权边时才成立</strong>）。</p>
<p>时间复杂度 O(V + E)，其中V为顶点（vertice）数，E为边数</p>
<p>实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"># 狄克斯特拉算法</span><br><span class="line"></span><br><span class="line">graph_weight = &#123;&#125;</span><br><span class="line"># 起点的邻居</span><br><span class="line">graph_weight[&apos;start&apos;] = &#123;&#125;</span><br><span class="line">graph_weight[&apos;start&apos;][&apos;a&apos;] = 6</span><br><span class="line">graph_weight[&apos;start&apos;][&apos;b&apos;] = 2</span><br><span class="line"></span><br><span class="line"># a的邻居</span><br><span class="line">graph_weight[&apos;a&apos;] = &#123;&#125;</span><br><span class="line">graph_weight[&apos;a&apos;][&apos;fin&apos;] = 1</span><br><span class="line"></span><br><span class="line"># b 的邻居</span><br><span class="line">graph_weight[&apos;b&apos;] = &#123;&#125;</span><br><span class="line">graph_weight[&apos;b&apos;][&apos;a&apos;] = 3</span><br><span class="line">graph_weight[&apos;b&apos;][&apos;fin&apos;] = 5</span><br><span class="line"></span><br><span class="line"># 终点</span><br><span class="line">graph_weight[&apos;fin&apos;] = &#123;&#125;</span><br><span class="line"></span><br><span class="line"># 开销</span><br><span class="line"></span><br><span class="line">infinity = float(&apos;inf&apos;)</span><br><span class="line">costs = &#123;&#125;</span><br><span class="line">costs[&apos;a&apos;] = 6</span><br><span class="line">costs[&apos;b&apos;] = 2</span><br><span class="line">costs[&apos;fin&apos;] = infinity</span><br><span class="line"></span><br><span class="line"># 父节点</span><br><span class="line">parents = &#123;&#125;</span><br><span class="line">parents[&apos;a&apos;] = &apos;start&apos;</span><br><span class="line">parents[&apos;b&apos;] = &apos;start&apos;</span><br><span class="line">parents[&apos;fin&apos;] = None</span><br><span class="line"></span><br><span class="line">processed = []</span><br><span class="line"># 找出开销最低的节点</span><br><span class="line"></span><br><span class="line">def find_lowest_cost_node(costs):</span><br><span class="line">    lowest_cost = float(&apos;inf&apos;)</span><br><span class="line">    lowest_cost_node = None</span><br><span class="line">    for node in costs:</span><br><span class="line">        cost = costs[node]</span><br><span class="line">        if cost &lt; lowest_cost and node not in processed:</span><br><span class="line">            lowest_cost = cost</span><br><span class="line">            lowest_cost_node = node</span><br><span class="line">    return lowest_cost_node</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">node = find_lowest_cost_node(costs)</span><br><span class="line"></span><br><span class="line">while node is not None:</span><br><span class="line">    cost =  costs[node]</span><br><span class="line">    neighbors = graph_weight[node]</span><br><span class="line">    for n in neighbors.keys():</span><br><span class="line">        new_cost = cost + neighbors[n]</span><br><span class="line">        if costs[n] &gt; new_cost:</span><br><span class="line">            costs[n] = new_cost</span><br><span class="line">            parents[n] = node</span><br><span class="line">    processed.append(node)</span><br><span class="line">    node = find_lowest_cost_node(costs)</span><br></pre></td></tr></table></figure></p>
<h2 id="第八章-贪婪算法"><a href="#第八章-贪婪算法" class="headerlink" title="第八章 贪婪算法"></a>第八章 贪婪算法</h2><p>每次都取最优解，<br>优劣评判标准：</p>
<ul>
<li>速度有多快</li>
<li>得到的近似解与最优解的接近程度<br><strong>NP完全问题</strong>：以难解著称的问题。<br>时间复杂度 O(n2)<br>实现：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># 贪婪算法</span><br><span class="line"></span><br><span class="line">states_need = set([&apos;mt&apos;, &apos;wa&apos;, &apos;or&apos;, &apos;id&apos;, &apos;nv&apos;, &apos;ut&apos;, &apos;ca&apos;, &apos;az&apos;])</span><br><span class="line"></span><br><span class="line">stations = &#123;&#125;</span><br><span class="line">stations[&apos;kone&apos;] = set([&apos;id&apos;, &apos;nv&apos;, &apos;ut&apos;])</span><br><span class="line">stations[&apos;ktwo&apos;] = set([&apos;wa&apos;, &apos;id&apos;, &apos;mt&apos;])</span><br><span class="line">stations[&apos;kthree&apos;] = set([&apos;or&apos;, &apos;nv&apos;, &apos;ca&apos;])</span><br><span class="line">stations[&apos;kfour&apos;] = set([&apos;nv&apos;, &apos;ut&apos;])</span><br><span class="line">stations[&apos;ktfive&apos;] = set([&apos;ca&apos;, &apos;az&apos;])</span><br><span class="line"></span><br><span class="line">final_stations = set()</span><br><span class="line"></span><br><span class="line"># 实现</span><br><span class="line">while states_need:</span><br><span class="line">    best_station = None</span><br><span class="line">    states_covered = set()</span><br><span class="line"></span><br><span class="line">    for station, states_for_station in stations.items():</span><br><span class="line">        covered = states_need &amp; states_for_station</span><br><span class="line">        if len(covered) &gt; len(states_covered):</span><br><span class="line">            best_station = station</span><br><span class="line">            states_covered = covered</span><br><span class="line">    final_stations.add(best_station)</span><br><span class="line">    states_need -= states_covered</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="第九章-动态规划"><a href="#第九章-动态规划" class="headerlink" title="第九章 动态规划"></a>第九章 动态规划</h2><p>限制：<em>动态规划功能强大，它能够解决子问题并使用这些答案来解决大问题。但仅当每个子问题都是离散的，即不依赖于其他子问题时，动态规划才管用</em><br><strong>2种计算维度</strong>：</p>
<ul>
<li><p>比较最长公共子串：两个字符串都包含的最长子串的长度，伪代码：</p>
<pre><code>if word_a[i] == word_b[j]: 
    cell[i][j] = cell[i-1][j-1] + 1 
else: 
    cell[i][j] = 0 
</code></pre></li>
<li><p>最长公共子序列：两个单词中都有的序列包含的字母数，伪代码：</p>
<pre><code>if word_a[i] == word_b[j]:
    cell[i][j] = cell[i-1][j-1] + 1 
else: 
    cell[i][j] = max(cell[i-1][j], cell[i][j-1])
</code></pre><p>应用：DNA相似度，git diff的实现</p>
</li>
</ul>
<p>具体适用场景：</p>
<ul>
<li>需要在给定约束条件下优化某种指标时，动态规划很有用。</li>
<li>问题可以分为离散问题时，可以使用动态规划来解决。</li>
<li>每种动态规划都涉及网络。</li>
<li>单元格的值就是要优化的值。</li>
<li>每一个单元格都是一个子问题，因此需要将问题划分为子问题。</li>
<li>计算动态规划的公式不唯一。</li>
</ul>
<h2 id="第十章-K最近邻算法"><a href="#第十章-K最近邻算法" class="headerlink" title="第十章 K最近邻算法"></a>第十章 K最近邻算法</h2><p>K最近邻算法（KNN）：</p>
<ol>
<li>对一个水果进行分类</li>
<li>查看他的最近3个邻居</li>
<li>邻居中最多的种类，是可能的类型</li>
</ol>
<p>回归：计算出邻居的平局值</p>
<p><strong>机器学习</strong>：<br>OCR（图像识别）原理，</p>
<ol>
<li>浏览大量数字图片，提取数字图片特征（线，点，曲线特征）。–<strong>训练</strong></li>
<li>遇到新图像时，提取图像的特征，找出他最近的邻居。</li>
</ol>
<p><em>**总结</em>：</p>
<ul>
<li>KNN就是用于分类和回归，需要考虑最近的邻居</li>
<li>分类就是编组</li>
<li>回归就是预测结果</li>
<li>特征抽取意味着将物品转换为一系列可比较的数字</li>
<li>能否挑选合适的特征事关KNN算法的成败</li>
</ul>
<h2 id="第十一章-十种算法"><a href="#第十一章-十种算法" class="headerlink" title="第十一章 十种算法"></a>第十一章 十种算法</h2><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>定义：对于每一个节点，左子节点的值都比他小，右子节点的值都比他大<br>对比快速排序：</p>
<ul>
<li>优点：二叉树查找法的插入和删除速度要快的很多；</li>
<li>缺点：不能随机访问</li>
</ul>
<p>扩展：<em>堆</em>：又被为优先队列(priority queue)。尽管名为优先队列，但堆并不是队列。回忆一下，在队列中，我们可以进行的限定操作是dequeue和enqueue。dequeue是按照进入队列的先后顺序来取出元素。而在堆中，我们不是按照元素进入队列的先后顺序取出元素的，而是按照元素的优先级取出元素。<a href="https://www.cnblogs.com/vamei/archive/2013/03/20/2966612.html" target="_blank" rel="noopener">堆</a></p>
<p>插入：进行名为<code>[precolate_up</code>的操作：在树的最后插入元素，和其父节点比较优先级大小，比父节点大就进行交换，直到优先级小于父节点。</p>
<p>删除：只能删除根节点，成为2个子树；让最后一个元素（last）成为根节点，进行<code>precolate_down</code>操作，不断比较last节点和子节点的优先级大小，如果last的优先级比2个子结点中小的那个大，则和其交换位置。</p>
<h3 id="反向索引"><a href="#反向索引" class="headerlink" title="反向索引"></a>反向索引</h3><p>定义：字典的key为单词，值为所在的页码</p>
<p>作用：用于搜索引擎</p>
<h3 id="傅里叶变换-？？"><a href="#傅里叶变换-？？" class="headerlink" title="傅里叶变换 ？？"></a>傅里叶变换 ？？</h3><h3 id="并行算法"><a href="#并行算法" class="headerlink" title="并行算法"></a>并行算法</h3><p>主要的问题：</p>
<ol>
<li>并行性管理开销：如何合理分配任务，如何有效合并任务</li>
<li>负载均衡：如何均匀的分配任务，让各个内核的任务达到负载均衡</li>
</ol>
<p><strong>MapReduce</strong>：流行的分布式算法</p>
<p>map（映射函数）：接受一个数组，并对每个元素执行同样的操作</p>
<p>reduce（归并函数）：将一个数组转化成一个元素。</p>
<h3 id="概率性算法"><a href="#概率性算法" class="headerlink" title="概率性算法"></a>概率性算法</h3><p><strong>布隆过滤器</strong>：一种概率性的数据结构，结果可能不对，很可能是正确的</p>
<ul>
<li>可能出错的情况：指出结果是正确时，结果可能是错误的</li>
<li>不可能错误的情况：指出结果是错误的情况时<br><strong>HyperLogLog</strong></li>
</ul>
<h3 id="SHA算法"><a href="#SHA算法" class="headerlink" title="SHA算法"></a>SHA算法</h3><p>散列函数：即反向索引<br>安全散列算法函数（SHA）：给定一个字符串，返回其散列值。<strong>无法根据散列值推算出字符串</strong><br>特点：局部不敏感：改动一个字符串，返回的散列值没有任何的相似性，</p>
<h3 id="Diffie-Hellman-密钥交换"><a href="#Diffie-Hellman-密钥交换" class="headerlink" title="Diffie-Hellman 密钥交换"></a>Diffie-Hellman 密钥交换</h3><p>特点:公钥和私钥结合使用：使用公钥生成散列值，使用私钥揭秘散列值。</p>
<h3 id="线性规划：即使用方程求最优化解"><a href="#线性规划：即使用方程求最优化解" class="headerlink" title="线性规划：即使用方程求最优化解"></a>线性规划：即使用方程求最优化解</h3>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/01/hexo-github搭建过程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Weidong Ji">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PrueMat">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/01/hexo-github搭建过程/" itemprop="url">hexo + github搭建过程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-01T10:21:04+08:00">
                2019-05-01
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/学习/" itemprop="url" rel="index">
                    <span itemprop="name">学习</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/学习/git-pages/" itemprop="url" rel="index">
                    <span itemprop="name">git pages</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ul>
<li>GitHub配置</li>
<li>hexo安装</li>
<li>hexo配置及命令</li>
<li>hexo</li>
</ul>
<h3 id="git-配置"><a href="#git-配置" class="headerlink" title="git 配置"></a>git 配置</h3><p>安装git，配置账户及ssh密钥，<a href="&#39;https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000&#39;" title="廖雪峰 Git教程">Git教程</a></p>
<p>github上创建git Pages项目，使用git托管项目名称为：<em><code>用户名.github.io</code></em>,项目权限必须是<em>public</em>;</p>
<h3 id="hexo-安装"><a href="#hexo-安装" class="headerlink" title="hexo 安装"></a>hexo 安装</h3><p>安装<a href="&#39;https://nodejs.org/en/download/&#39;" title="Node.js">node.js</a><br>安装hexo，进入cmd执行安装命令：</p>
<pre><code>npm install -g hexo-cli
</code></pre><p>初始化hexo项目blog：创建一个Blog文件夹，cmd在该目录下执行</p>
<pre><code>hexo init blog
</code></pre><p>启动hexo</p>
<pre><code>hexo g
hexo s
</code></pre><p>部署hexo</p>
<pre><code>hexo d
</code></pre><p>tips：部署后打开站点修改可能不会立即生效，需要等待</p>
<h3 id="hexo-配置及命令"><a href="#hexo-配置及命令" class="headerlink" title="hexo 配置及命令"></a>hexo 配置及命令</h3><h4 id="站点配置，配置文件-blog-config-yml"><a href="#站点配置，配置文件-blog-config-yml" class="headerlink" title="站点配置，配置文件 blog/_config.yml"></a>站点配置，配置文件 <code>blog/_config.yml</code></h4><p>基本信息</p>
<pre><code># Site
title: PrueMat # 站点名称
subtitle:
description:
keywords:
author: Weidong Ji
language: zh-Hans # 中文
timezone: Asia/Shanghai #
</code></pre><p>主题：</p>
<pre><code>theme: next
</code></pre><p>部署：</p>
<pre><code># Deployment
## Docs: https://hexo.io/docs/deployment.html
deploy: # 部署配置
type: git #部署方式
repo: https://github.com/WeidongJ/WeidongJ.github.io.git # git
branch: master
</code></pre><p>Tips:修改站点配置后需要执行clean命令才能生效：</p>
<pre><code>hexo clean
hexo g
hexo s
</code></pre><h4 id="主题配置（next）"><a href="#主题配置（next）" class="headerlink" title="主题配置（next）"></a>主题配置（next）</h4><p>使用命令clone next主题文件夹</p>
<pre><code>git clone https://github.com/iissnan/hexo-theme-next themes/next
</code></pre><p>修改样式，配置文件 <code>blog/themes/next/_config.yml</code></p>
<pre><code># Schemes
#scheme: Muse
#scheme: Mist
scheme: Pisces # 指定样式
#scheme: Gemini
</code></pre><p>tips：非站点配置，一般不用执行clean命令</p>
<pre><code>hexo g
hexo s
</code></pre><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="迁移本地hexo文件及配置至git"><a href="#迁移本地hexo文件及配置至git" class="headerlink" title="迁移本地hexo文件及配置至git"></a>迁移本地hexo文件及配置至git</h3><p>cmd至Blog目录，把文件夹推送至项目 dev 分支</p>
<pre><code>git push git@github.com:WeidongJ/WeidongJ.github.io.git -b dev
</code></pre><p>问题：推送出去的next文件夹不可用</p>
<p>原因：next文件夹是git项目</p>
<p>解决方法：</p>
<ol>
<li>设置windows查看，显示隐藏项目，删除<code>.git</code></li>
<li>删除git上next文件夹</li>
<li>重新 push</li>
</ol>
<h3 id="相关"><a href="#相关" class="headerlink" title="相关"></a>相关</h3><p>hexo 使用介绍：<a href="&#39;https://hexo.io/zh-cn/docs/&#39;" title="hexo doc">hexo文档</a><br>next 使用介绍：<a href="&#39;https://theme-next.org/docs/&#39;" title="next doc">next文档</a><br>markdown 使用介绍：<a href="&#39;http://www.markdown.cn/&#39;" title="markdown doc">markdown文档</a></p>
<h3 id="待学习"><a href="#待学习" class="headerlink" title="待学习"></a>待学习</h3><p>hexo 分享及页面定制，嵌入等</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Weidong Ji</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Weidong Ji</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>

<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="python,基础知识,">










<meta name="description" content="数据类型和变量 python中int没有大小限制， 无限大可以使用inf来表示；常量通常使用大写字母表示。 utf-8是可变长编码：可以根据一个Unicode字符根据字节大小编码成1-6个字节；计算机中编码的工作方式如下：   用记事本编辑的时候，从文件读取的UTF-8字符被转换为Unicode字符到内存里，编辑完成后，保存的时候再把Unicode转换为UTF-8保存到文件:  ord()函数可以">
<meta name="keywords" content="python,基础知识">
<meta property="og:type" content="article">
<meta property="og:title" content="python基础知识复习">
<meta property="og:url" content="http://yoursite.com/2019/06/08/python基础知识复习/index.html">
<meta property="og:site_name" content="PrueMat">
<meta property="og:description" content="数据类型和变量 python中int没有大小限制， 无限大可以使用inf来表示；常量通常使用大写字母表示。 utf-8是可变长编码：可以根据一个Unicode字符根据字节大小编码成1-6个字节；计算机中编码的工作方式如下：   用记事本编辑的时候，从文件读取的UTF-8字符被转换为Unicode字符到内存里，编辑完成后，保存的时候再把Unicode转换为UTF-8保存到文件:  ord()函数可以">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://yoursite.com/2019/06/08/python基础知识复习/encode.png">
<meta property="og:image" content="http://yoursite.com/2019/06/08/python基础知识复习/DAG.jpg">
<meta property="og:image" content="http://yoursite.com/2019/06/08/python基础知识复习/topo_sorted.webp">
<meta property="og:updated_time" content="2019-06-12T23:57:02.687Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="python基础知识复习">
<meta name="twitter:description" content="数据类型和变量 python中int没有大小限制， 无限大可以使用inf来表示；常量通常使用大写字母表示。 utf-8是可变长编码：可以根据一个Unicode字符根据字节大小编码成1-6个字节；计算机中编码的工作方式如下：   用记事本编辑的时候，从文件读取的UTF-8字符被转换为Unicode字符到内存里，编辑完成后，保存的时候再把Unicode转换为UTF-8保存到文件:  ord()函数可以">
<meta name="twitter:image" content="http://yoursite.com/2019/06/08/python基础知识复习/encode.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/06/08/python基础知识复习/">





  <title>python基础知识复习 | PrueMat</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">PrueMat</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-schedule">
          <a href="/schedule/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-calendar"></i> <br>
            
            日程表
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/08/python基础知识复习/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Weidong Ji">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PrueMat">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">python基础知识复习</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-08T09:39:01+08:00">
                2019-06-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="数据类型和变量"><a href="#数据类型和变量" class="headerlink" title="数据类型和变量"></a>数据类型和变量</h2><ul>
<li>python中int没有大小限制， 无限大可以使用<code>inf</code>来表示；常量通常使用大写字母表示。</li>
<li><p><code>utf-8</code>是可变长编码：可以根据一个Unicode字符根据字节大小编码成1-6个字节；计算机中编码的工作方式如下：</p>
<p>  用记事本编辑的时候，从文件读取的UTF-8字符被转换为Unicode字符到内存里，编辑完成后，保存的时候再把Unicode转换为UTF-8保存到文件:</p>
<img src="/2019/06/08/python基础知识复习/encode.png" title="encode"></li>
<li><code>ord()</code>函数可以获取字符的整数表示，<code>chr()</code>可以把编码转换成对应的字符。</li>
<li><p>bytes类型的数据用<code>b&#39;ABC&#39;</code>表示，与字符串<code>ABC</code>的差别是bytes类型每个字符只占一个字节。把字符串转换成bytes型使用<code>encode()</code>方法，使用<code>decode()</code>可以把bytes转换成字符串。</p>
<pre><code>&gt;&gt;&gt; &apos;中文&apos;.encode(&apos;utf-8&apos;)
b&apos;\xe4\xb8\xad\xe6\x96\x87&apos;
</code></pre></li>
<li>dict的key必须是不可变对象，因为dict是根据key来计算存储位置，key可变，dict内部就全乱了。</li>
<li><p><strong>zip()</strong>：函数用于将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的列表，如果各个迭代器的元素个数不一致，则返回列表长度与最短的对象相同，利用 * 号操作符，可以将元组解压为列表。</p>
<pre><code>&gt;&gt;&gt;a = [1,2,3]
&gt;&gt;&gt; b = [4,5,6]
&gt;&gt;&gt; c = [4,5,6,7,8]
&gt;&gt;&gt; zipped = zip(a,b)     # 打包为元组的列表
[(1, 4), (2, 5), (3, 6)]
&gt;&gt;&gt; zip(a,c)              # 元素个数与最短的列表一致
[(1, 4), (2, 5), (3, 6)]
&gt;&gt;&gt; zip(*zipped)          # 与 zip 相反，*zipped 可理解为解压，返回二维矩阵式
[(1, 2, 3), (4, 5, 6)]
</code></pre></li>
</ul>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数名其实就是指向一个函数对象的引用，完全可以把函数名赋给一个变量，相当于给这个函数起了一个“别名”：</p>
<pre><code>&gt;&gt;&gt; a = abs # 变量a指向abs函数
&gt;&gt;&gt; a(-1) # 所以也可以通过a调用abs函数
1
</code></pre><h3 id="函数的参数"><a href="#函数的参数" class="headerlink" title="函数的参数"></a>函数的参数</h3><p>默认参数</p>
<pre><code>def power(x, n=2):
    s = 1
    while n &gt; 0:
        n = n - 1
        s = s * x
    return s
</code></pre><p>默认参数必须指向不变对象：Python函数在定义的时候，默认参数L的值就被计算出来了，即[]，因为默认参数L也是一个变量，它指向对象[]，每次调用该函数，如果改变了L的内容，则下次调用时，默认参数的内容就变了，不再是函数定义时的[]了。</p>
<pre><code>def add_end(L=[]):
    L.append(&apos;END&apos;)
    return L

&gt;&gt;&gt; add_end()
[&apos;END&apos;, &apos;END&apos;]
&gt;&gt;&gt; add_end()
[&apos;END&apos;, &apos;END&apos;, &apos;END&apos;]
</code></pre><p>可变参数：<br>    def calc(<em>numbers):<br>        sum = 0<br>        for n in numbers:<br>            sum = sum + n </em> n<br>        return sum<br>*nums表示把nums这个list的所有元素作为可变参数传进去。这种写法相当有用，而且很常见：</p>
<pre><code>&gt;&gt;&gt; nums = [1, 2, 3]
&gt;&gt;&gt; calc(*nums)
14
</code></pre><p>递归：函数内部调用自己本身。</p>
<p>使用递归需要注意防止栈溢出。可以使用尾递归优化，尾递归即调用自己本身时 return语句不包含表达式，效果等同于循环。</p>
<pre><code># 汉诺塔移动
def move(n, a, b, c):
    if n == 1:
        print(a, &apos;--&gt;&apos;, c)
    else:
        move(n-1, a, c, b)
        move(1, a, b, c)
        move(n-1, b, c, a)
</code></pre><h3 id="函数高级特性"><a href="#函数高级特性" class="headerlink" title="函数高级特性"></a>函数高级特性</h3><p>python内置函数<code>enumerate()</code>可以把列表变成一个索引-元素对。</p>
<pre><code>&gt;&gt;&gt; for i, value in enumerate([&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]):
...     print(i, value)
...
0 A
1 B
2 C
</code></pre><p><strong>生成式（generate）</strong>：列表元素根据某种算法推算出来，循环种不对退算后面的数，不需要创建完整的列表，以节省大量的空间；使用()创建一个生成器，列表生成式使用[]，使用next()获取下一个返回值，最后抛出StopIteration异常。</p>
<p>斐波拉契数列：</p>
<pre><code># 列表生成式
def fib(x):
    n, a, b = 0, 0, 1
    while n &lt; max:
        print(b)
        a, b = a, a + b
        n += 1
    return &apos;done&apos;
</code></pre><p>generator的另一种方法。如果一个函数定义中包含yield关键字，那么这个函数就不再是一个普通函数，而是一个generator：</p>
<pre><code># 生成器
def fib(x):
    n, a, b = 0, 0, 1
    while n &lt; max:
        yield b
        a, b = a, a + b
        n += 1
    return &apos;done&apos;
</code></pre><p>最难理解的就是generator和函数的执行流程不一样。函数是顺序执行，遇到return语句或者最后一行函数语句就返回。而变成generator的函数，<strong>在每次调用next()的时候执行，遇到yield语句返回，再次执行时从上次返回的yield语句处继续执行。</strong></p>
<pre><code>def odd():
print(&apos;step 1&apos;)
yield 1
print(&apos;step 2&apos;)
yield(3)
print(&apos;step 3&apos;)
yield(5)

&gt;&gt;&gt; o = odd()
&gt;&gt;&gt; next(o)
step 1
1
&gt;&gt;&gt; next(o)
step 2
3
&gt;&gt;&gt; next(o)
step 3
5
&gt;&gt;&gt; next(o)
Traceback (most recent call last):
File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
StopIteration
</code></pre><p>杨辉三角：<br>    def trangles():<br>        L = [1]<br>        while True:<br>            yield L<br>            L = [1] + [L[a] + L[a+1] for a in range(0,len(L)-1)] + [1]</p>
<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><ul>
<li>可以直接作用于for循环的对象统称为可迭代对象：<strong>Iterable</strong>。</li>
<li>可以被next()函数调用并不断返回下一个值的对象称为迭代器：<strong>Iterator</strong>。</li>
</ul>
<p>Python的Iterator对象表示的是一个数据流，Iterator对象可以被next()函数调用并不断返回下一个数据，直到没有数据时抛出StopIteration错误。可以把这个数据流看做是一个有序序列，但我们却不能提前知道序列的长度，只能不断通过next()函数实现按需计算下一个数据，所以Iterator的计算是惰性的，只有在需要返回下一个数据时它才会计算。Iterator甚至可以表示一个无限大的数据流，例如全体自然数。而使用list是永远不可能存储全体自然数的。</p>
<p>Python的for循环本质上就是通过不断调用next()函数实现的</p>
<h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h2><p>函数式编程就是一种抽象程度很高的编程范式，纯粹的函数式编程语言编写的函数没有变量，因此，任意一个函数，只要输入是确定的，输出就是确定的，这种纯函数我们称之为没有副作用。而允许使用变量的程序设计语言，由于函数内部的变量状态不确定，同样的输入，可能得到不同的输出，因此，这种函数是有副作用的。</p>
<p>函数式编程的一个特点就是，允许把函数本身作为参数传入另一个函数，还允许返回一个函数！</p>
<h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><p>一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数</p>
<p>变量可以指向函数</p>
<pre><code>&gt;&gt;&gt; f = abs
&gt;&gt;&gt; f(-10)
10
</code></pre><h3 id="map-reduce"><a href="#map-reduce" class="headerlink" title="map()/reduce()"></a>map()/reduce()</h3><p><code>map()</code>函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的<strong>Iterator</strong>返回。</p>
<pre><code>&gt;&gt;&gt; list(map(str, [1, 2, 3, 4, 5, 6, 7, 8, 9]))
[&apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos;]
</code></pre><p><code>reduce()</code>把一个函数作用在一个序列[x1, x2, x3, …]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算，其效果就是。</p>
<pre><code>&gt;&gt;&gt; from functools import reduce
&gt;&gt;&gt; def add(x, y):
...     return x + y
...
&gt;&gt;&gt; reduce(add, [1, 3, 5, 7, 9])
25
</code></pre><p><code>filter()</code>也接收一个函数和一个序列。和map()不同的是，filter()把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素,返回一个<strong>Iterator</strong>。</p>
<p><code>sorted()</code>排序</p>
<pre><code>&gt;&gt;&gt; sorted([&apos;bob&apos;, &apos;about&apos;, &apos;Zoo&apos;, &apos;Credit&apos;], key=str.lower, reverse=True)
[&apos;Zoo&apos;, &apos;Credit&apos;, &apos;bob&apos;, &apos;about&apos;]
</code></pre><h3 id="返回函数"><a href="#返回函数" class="headerlink" title="返回函数"></a>返回函数</h3><p>高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回。</p>
<pre><code>def lazy_sum(*args):
    def sum():
        ax = 0
        for n in args:
            ax = ax + n
        return ax
    return sum
</code></pre><p>调用<code>lazy_sum()</code>时，返回求和函数；并且每次调用时都返回一个新的函数：</p>
<pre><code>&gt;&gt;&gt; f = lazy_sum(1, 3, 5, 7, 9)
&gt;&gt;&gt; f
&lt;function lazy_sum.&lt;locals&gt;.sum at 0x101c6ed90&gt;

&gt;&gt;&gt; f1 = lazy_sum(1, 3, 5, 7, 9)
&gt;&gt;&gt; f2 = lazy_sum(1, 3, 5, 7, 9)
&gt;&gt;&gt; f1==f2
False
</code></pre><p>闭包：我们在函数<code>lazy_sum</code>中又定义了函数<code>sum</code>，并且，内部函数<code>sum</code>可以引用外部函数<code>lazy_sum</code>的参数和局部变量，当<code>lazy_sum</code>返回函数<code>sum</code>时，<strong>相关参数和变量都保存在返回的函数中</strong>，这种称为“闭包（Closure）”的程序结构拥有极大的威力。</p>
<p>返回的函数并没有立刻执行，而是直到调用了f()才执行。</p>
<pre><code>def count():
    fs = []
    for i in range(1, 4):
        def f():
            return i*i
        fs.append(f)
    return fs

f1, f2, f3 = count()
&gt;&gt;&gt; f1()
9
&gt;&gt;&gt; f2()
9
&gt;&gt;&gt; f3()
9
</code></pre><p>全部都是9！原因就在于返回的函数引用了变量i，但它并非立刻执行。等到3个函数都返回时，它们所引用的变量i已经变成了3，因此最终结果为9。<strong>返回闭包时牢记一点：返回函数不要引用任何循环变量，或者后续会发生变化的变量。</strong></p>
<p>一定要引用循环变量怎么办？方法是再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变:<br>    def count():<br>        def f(j):<br>            def g():<br>                return j*j<br>            return g<br>        fs = []<br>        for i in range(1, 4):<br>            fs.append(f(i)) # f(i)立刻被执行，因此i的当前值被传入f()<br>        return fs # 返回一个列表</p>
<p>计数器：</p>
<pre><code>def createCounter():
    li = 0
    def counter():
        li += 1
        return li
    return counter
</code></pre><p>上述代码会报错：当你在当前作用域中的给变量赋值时，该变量将成为该作用域的局部变量，并在外部范围中隐藏任何类似命名的变量。</p>
<pre><code>def createCounter():
    l = [0]
    def counter():
        l[0] = l[0] + 1
        return l[0]
    return counter
</code></pre><h3 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h3><p>在代码运行期间动态增加功能的方式，成为<strong>装饰器（Decorator）</strong>；本质上decorator就是一个返回函数的高阶函数。</p>
<pre><code># 装饰器
def log(func):
    @functools.wraps(func)
    def wrapper(*args, **kw):
        print(&apos;call %s()&apos; % func.__name__)
        return func(*args, **kw)
    return wrapper

@log
def now():
    print(&apos;Hello World!&apos;)

def log_text(text):
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kw):
            print(&apos;%s %s()&apos; % (text, func.__name__))
            return func(*args, **kw)
        return wrapper
    return decorator

@log_text(&apos;调用&apos;)
def new_now():
    print(&apos;Hello World!&apos;)
</code></pre><p>Python内置的<code>functools.wraps</code>，把原始函数的<code>__name__</code>属性复制到<code>wrapper()</code>中.</p>
<p>偏函数</p>
<p><code>functools.partial</code>的作用就是，把一个函数的某些参数给固定住（也就是设置默认值），返回一个新的函数，调用这个新函数会更简单。</p>
<pre><code>&gt;&gt;&gt; import functools
&gt;&gt;&gt; int2 = functools.partial(int, base=2)
&gt;&gt;&gt; int2(&apos;1000000&apos;)
64
</code></pre><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p><code>sys</code>模块有一个<code>argv</code>变量，用list存储了命令行的所有参数。运行python3 hello.py Michael获得的sys.argv就是[‘hello.py’, ‘Michael]。</p>
<p>当我们在命令行运行hello模块文件时，Python解释器把一个特殊变量<code>__name__</code>置为<code>__main__</code>，而如果在其他地方导入该hello模块时，if判断将失败，因此，这种if测试可以让一个模块通过命令行运行时执行一些额外的代码，最常见的就是运行测试</p>
<pre><code>if __name__==&apos;__main__&apos;:
test()
</code></pre><h2 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h2><p>类和实例</p>
<p>和静态语言不同，Python允许对实例变量绑定任何数据，也就是说，对于两个实例变量，虽然它们都是同一个类的不同实例，但拥有的变量名称都可能不同。</p>
<p>访问限制</p>
<p>使用<code>__</code>限制属性访问，改为增加<code>get/se</code>t方法是因为<strong>在方法中可以对参数做检查</strong>。</p>
<ul>
<li><code>__xxx__</code> 特殊变量。</li>
<li><code>_xxx</code> 约定的私有变量：虽然我可以被访问，但是，请把我视为私有变量，不要随意访问。</li>
<li><code>__xx</code> 私有变量，python解释器把<code>__xx</code>对外改变成<code>_ClassName__xx</code></li>
</ul>
<p>外部设置变量错误，际上这个<strong>name变量和class内部的</strong>name变量不是一个变量！内部的<strong>name变量已经被Python解释器自动改成了_Student</strong>name，而外部代码给bart新增了一个__name变量：</p>
<pre><code>&gt;&gt;&gt; bart = Student(&apos;Bart Simpson&apos;, 59)
&gt;&gt;&gt; bart.get_name()
&apos;Bart Simpson&apos;
&gt;&gt;&gt; bart.__name = &apos;New Name&apos; # 设置__name变量！
&gt;&gt;&gt; bart.__name
&apos;New Name&apos;
</code></pre><h3 id="继承和多态"><a href="#继承和多态" class="headerlink" title="继承和多态"></a>继承和多态</h3><p><strong>继承</strong>：子类获得了父类的全部功能。</p>
<p><strong>多态</strong>：对于一个变量，我们只需要知道它是Animal类型，无需确切地知道它的子类型，就可以放心地调用run()方法，而具体调用的run()方法是作用在Animal、Dog、Cat还是Tortoise对象上，由运行时该对象的确切类型决定，这就是多态真正的威力：调用方只管调用，不管细节，而当我们新增一种Animal的子类时，只要确保run()方法编写正确，不用管原来的代码是如何调用的。这就是著名的“开闭”原则：</p>
<pre><code>class Animal(object):
def run(self):
    print(&apos;Animal is running...&apos;)

class Dog(Animal):
    def run(self):
        print(&apos;Dog is running...&apos;)

def run_twice(animal):
    animal.run()
    animal.run()

run_twice(Animal())
run_twice(Dog())

Animal is running...
Animal is running...
Dog is running...
Dog is running...
</code></pre><ul>
<li>对扩展开放：允许新增Animal子类。</li>
<li>对修改封闭：不需要修改依赖Animal类型的run_twice()等函数。</li>
</ul>
<p>动态语言vs静态语言</p>
<p>对于静态语言（例如Java）来说，如果需要传入Animal类型，则传入的对象必须是Animal类型或者它的子类，否则，将无法调用run()方法。</p>
<p>对于Python这样的动态语言来说，则不一定需要传入Animal类型。我们只需要保证传入的对象有一个run()方法就可以了：</p>
<pre><code>class Timer(object):
    def run(self):
        print(&apos;start...&apos;)

run_twice(Timer())

start...
start...
</code></pre><p>这就是动态语言的“<strong>鸭子类型</strong>”，它并不要求严格的继承体系，一个对象只要“看起来像鸭子，走起路来像鸭子”，那它就可以被看做是鸭子。</p>
<h3 id="获取对象信息"><a href="#获取对象信息" class="headerlink" title="获取对象信息"></a>获取对象信息</h3><p><code>type()</code>用于判断对象的类型,使用<code>isinstance()</code>判断继承关系。</p>
<p><code>dir()</code>获取对象的所有属性，实际上<code>len()</code>方法是自动调用该对象的<code>__len__()</code>方法</p>
<p>配合<code>getattr()</code>、<code>setattr()</code>以及<code>hasattr()</code>，我们可以直接操作一个对象的状态:</p>
<pre><code>&gt;&gt;&gt; class MyObject(object):
...     def __init__(self):
...         self.x = 9
...     def power(self):
...         return self.x * self.x
...
&gt;&gt;&gt; obj = MyObject()

&gt;&gt;&gt; hasattr(obj, &apos;x&apos;) # 有属性&apos;x&apos;吗？
True
&gt;&gt;&gt; obj.x
9
&gt;&gt;&gt; hasattr(obj, &apos;y&apos;) # 有属性&apos;y&apos;吗？
False
&gt;&gt;&gt; setattr(obj, &apos;y&apos;, 19) # 设置一个属性&apos;y&apos;
&gt;&gt;&gt; hasattr(obj, &apos;y&apos;) # 有属性&apos;y&apos;吗？
True
&gt;&gt;&gt; getattr(obj, &apos;y&apos;) # 获取属性&apos;y&apos;
19
&gt;&gt;&gt; obj.y # 获取属性&apos;y&apos;
19
</code></pre><h3 id="实例属性和类属性"><a href="#实例属性和类属性" class="headerlink" title="实例属性和类属性"></a>实例属性和类属性</h3><p>不可对实例属性和类属性使用相同的名字，因为相同名称的实例属性将屏蔽掉类属性，但是当你删除实例属性后，再使用相同的名称，访问到的将是类属性。</p>
<pre><code>&gt;&gt;&gt; class Student(object):
...     name = &apos;Student&apos;
...
&gt;&gt;&gt; s = Student() # 创建实例s
&gt;&gt;&gt; print(s.name) # 打印name属性，因为实例并没有name属性，所以会继续查找class的name属性
Student
&gt;&gt;&gt; print(Student.name) # 打印类的name属性
Student
&gt;&gt;&gt; s.name = &apos;Michael&apos; # 给实例绑定name属性
&gt;&gt;&gt; print(s.name) # 由于实例属性优先级比类属性高，因此，它会屏蔽掉类的name属性
Michael
&gt;&gt;&gt; print(Student.name) # 但是类属性并未消失，用Student.name仍然可以访问
Student
&gt;&gt;&gt; del s.name # 如果删除实例的name属性
&gt;&gt;&gt; print(s.name) # 再次调用s.name，由于实例的name属性没有找到，类的name属性就显示出来了
Student
</code></pre><p>给Student类增加一个类属性，每创建一个实例，该属性自动增加：</p>
<pre><code>class Student(object):
    count = 0

    def __init__(self, name):
        self.name = name
        Student.count += 1 # 访问类属性
</code></pre><p>变量的类型：</p>
<ol>
<li>全局变量 - 在所有函数和类的外面</li>
<li>局部变量 -  <ol>
<li>在函数内</li>
<li>在class的方法内，未加 self 修饰</li>
</ol>
</li>
<li>静态变量 - 在class内，并且是在方法外</li>
<li>实例变量 - 在class方法内，用self修饰</li>
</ol>
<h2 id="面向对象高级编程"><a href="#面向对象高级编程" class="headerlink" title="面向对象高级编程"></a>面向对象高级编程</h2><p>给实例绑定一个属性：</p>
<pre><code>class Student(object):
    pass

&gt;&gt;&gt; s = Student()
&gt;&gt;&gt; s.name = &apos;Michael&apos; # 动态给实例绑定一个属性
&gt;&gt;&gt; print(s.name)
Michael
</code></pre><p>给实例绑定一个方法：</p>
<pre><code>&gt;&gt;&gt; def set_age(self, age): # 定义一个函数作为实例方法
...     self.age = age
...
&gt;&gt;&gt; from types import MethodType
&gt;&gt;&gt; s.set_age = MethodType(set_age, s) # 给实例绑定一个方法
&gt;&gt;&gt; s.set_age(25) # 调用实例方法
&gt;&gt;&gt; s.age # 测试结果
25
</code></pre><p>给类绑定一个方法：</p>
<pre><code>&gt;&gt;&gt; def set_score(self, score):
...     self.score = score
...
&gt;&gt;&gt; Student.set_score = set_scor
</code></pre><p>使用<code>__slots__</code>可以限制实例的属性,使用<strong>slots</strong>要注意，<strong>slots</strong>定义的属性仅对当前类实例起作用，对继承的子类是不起作用的。</p>
<pre><code>class Student(object):
    __slots__ = (&apos;name&apos;, &apos;age&apos;) # 用tuple定义允许绑定的属性名称
</code></pre><p><code>@property</code>装饰器就是负责把一个方法变成属性调用的:</p>
<pre><code>class Student(object):

    @property
    def score(self):
        return self._score

    @score.setter
    def score(self, value):
        if not isinstance(value, int):
            raise ValueError(&apos;score must be an integer!&apos;)
        if value &lt; 0 or value &gt; 100:
            raise ValueError(&apos;score must between 0 ~ 100!&apos;)
        self._score = value

&gt;&gt;&gt; s = Student()
&gt;&gt;&gt; s.score = 60 # OK，实际转化为s.set_score(60)
&gt;&gt;&gt; s.score # OK，实际转化为s.get_score()
60
&gt;&gt;&gt; s.score = 9999
Traceback (most recent call last):
...
ValueError: score must between 0 ~ 100!
</code></pre><p>注意：<code>@property</code> 赋值时需要使用<code>_xx</code></p>
<h3 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h3><p>Mixln：在设计类的继承关系时，通常主线都是翻译继承下来的，但是如果需要“混入”额外的功能，通过多重继承可以实现。这种设计模式通常称为Mixln。Mixln的目的就是给一个类增加多个功能。</p>
<p>tips：多重继承中的属性或者方法重复，遵循取左原则</p>
<pre><code>class A(object):

    def __init__(self):
        self.name = &apos;A&apos;

class B(object):

    def __init__(self):
        self.name = &apos;B&apos;

class C(A, B):
    pass

class D(B, A):
    pass

a = C()
print(a.name)
b = D()
print(b.name)

A
B
</code></pre><p>python继承的优先顺序：按照拓扑排序：</p>
<p>在图论中，拓扑排序(Topological Sorting) 是一个 有向无环图(DAG,Directed Acyclic Graph) 的所有顶点的线性序列。且该序列必须满足下面两个条件：</p>
<ul>
<li>每个顶点出现且只出现一次。</li>
<li>若存在一条从顶点A到B的路径，那么序列中顶点A在B的前面。<img src="/2019/06/08/python基础知识复习/DAG.jpg" title="Topological Sorting">
</li>
</ul>
<p>它是一个DAG图，那么如何写出它的拓扑顺序呢？这里说一种比较常用的方法：</p>
<ul>
<li>从DAG途中选择一个没有前驱(即没有指向其的箭头)的顶点并输出。</li>
<li>从图中删除该顶点和所有以它为起点的有向边。</li>
<li>重复1和2直到当前DAG图为空或当前途中不存在无前驱的顶点为止。后一种情况说明有向图中必然存在环。<img src="/2019/06/08/python基础知识复习/topo_sorted.webp" title="Topo_sorted">
</li>
</ul>
<p>python C3算法遍历DAG顺序寻找方法，优先找到即调用。</p>
<h2 id="定制类"><a href="#定制类" class="headerlink" title="定制类"></a>定制类</h2><p><code>__str__()</code>存储了实例的字符串：</p>
<pre><code>class Student(object):
    count = 0

    def __init__(self, name):
        self.name = name
        Student.count += 1 # 访问类属性

    def __str__(self):
        return &apos;Student object (name: %s)&apos; % self.name

print(Student(&apos;wdji&apos;))

Student object (name: wdji)
</code></pre><p>直接线是调用的变量还是不好看：</p>
<pre><code>&gt;&gt;&gt; s = Student(&apos;Michael&apos;)
&gt;&gt;&gt; s
&lt;__main__.Student object at 0x109afb310&gt;
</code></pre><p>因为直接显示变量调用的不是<code>__str__()</code>，而是<code>__repr__()</code>，两者的区别是<code>__str__()</code>返回用户看到的字符串，而<code>__repr__()</code>返回程序开发者看到的字符串，也就是说，<code>__repr__()</code>是为调试服务的。</p>
<pre><code>class Student(object):
    count = 0

    def __init__(self, name):
        self.name = name
        Student.count += 1 # 访问类属性

    def __str__(self):
        return &apos;Student object (name: %s)&apos; % self.name

    __repr__ == __str__
</code></pre><p><code>__iter__()</code>一个类想被<code>for ... in</code>循环，类似list，tuple就必须实现一个<code>__iter__()</code>方法，该方法返回一个迭代对象。</p>
<pre><code>class Fib(object):

    def __init__(self):
        self.a, self.b = 0, 1

    def __iter__(self):
        return self

    def __next__(self):
        self.a , self.b = self.b, self.a + self.b
        if self.a &gt; 1000:
            raise StopIteration()
        return self.a

for n in Fib():
    print(n)

1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987
</code></pre><p><code>__getitem__()</code>:实现像list一样取出按照下表取出元素</p>
<pre><code>class Fib(object):

    def __getitem__(self, n):
        a, b = 1, 1
        for x in range(n):
            a, b = b, a + b
        return a

f = Fib()
print(f[5]) # 8
</code></pre><p>实现切片需要判断n的类型：</p>
<pre><code>class Fib(object):

    def __getitem__(self, n):
        if isinstance(n, int):
            a, b = 1, 1
            for _ in range(n):
                a, b = b, a + b
            return a
        if isinstance(n, slice):
            start = n.start
            stop = n.stop
            if start is None:
                start = 0
            a, b = 1, 1
            L = []
            for x in range(stop):
                if x &gt;= start:
                    L.append(a)
                a, b = b, a + b
            return L

f = Fib()
print(f[5:10]) # [8, 13, 21, 34, 55]
</code></pre><p>以上没有处理step和负数，所以实现一个<code>__getitem__()</code>还有很多工作要做。如果把对象看成dict，<code>__getitem__()</code>的参数也可能是一个可以作key的object，例如str。</p>
<p>与之对应的是<code>__setitem__()</code>方法，把对象视作list或dict来对集合赋值。最后，还有一个<code>__delitem__()</code>方法，用于删除某个元素。通过上面的方法，我们自己定义的类表现得和Python自带的list、tuple、dict没什么区别，这完全归功于动态语言的“鸭子类型”，不需要强制继承某个接口。</p>
<p><code>__getattr__()</code></p>
<p>调用不存在的属性时会报错，可以用<code>__getattr__()</code>实现动态的返回一个属性。</p>
<pre><code>class Student(object):
    count = 0

    def __init__(self, name):
        self.name = name
        Student.count += 1 # 访问类属性

    def __str__(self):
        return &apos;Student object (name: %s)&apos; % self.name

    def __getattr__(self, attr):
        if attr == &apos;age&apos;:
            return lambda: 25
        raise AttributeError(&apos;\&apos;Student\&apos; object has no attribute \&apos;%s\&apos;&apos; % attr)

print(Student(&apos;wdji&apos;))
a = Student(&apos;wdji2&apos;)
print(a.age()) # 25
print(a.grade) # AttributeError: &apos;Student&apos; object has no attribute &apos;grade&apos;
</code></pre><p>动态调用的特性可以用在网站的REST API；利用完全动态的<code>__getattr__()</code>写出一个链式调用。</p>
<pre><code>class Chain(object):

    def __init__(self, path=&apos;&apos;):
        self._path = path

    def __getattr__(self, path):
        return Chain(&apos;%s/%s&apos; % (self._path, path))

    def __str__(self):
        return self._path

    __repr__ = __str__
</code></pre><p><code>__call__()</code></p>
<p>定义一个<strong>call</strong>()方法，就可以直接对实例进行调用:</p>
<pre><code>class Student(object):
    def __init__(self, name):
        self.name = name

    def __call__(self):
        print(&apos;My name is %s.&apos; % self.name)

&gt;&gt;&gt; s = Student(&apos;Michael&apos;)
&gt;&gt;&gt; s() # self参数不要传入
My name is Michael.
</code></pre><p><code>__call__()</code>还可以定义参数。<strong>对实例进行直接调用就好比对一个函数进行调用一样，所以你完全可以把对象看成函数，把函数看成对象，因为这两者之间本来就没啥根本的区别。如果你把对象看成函数，那么函数本身其实也可以在运行期动态创建出来，因为类的实例都是运行期创建出来的，这么一来，我们就模糊了对象和函数的界限</strong>。</p>
<p>那么，怎么判断一个变量是对象还是函数呢？其实，更多的时候，我们需要判断一个对象是否能被调用，能被调用的对象就是一个Callable对象，比如函数和我们上面定义的带有<strong>call</strong>()的类实例：</p>
<pre><code>&gt;&gt;&gt; callable(Student())
True
&gt;&gt;&gt; callable(max)
True
&gt;&gt;&gt; callable([1, 2, 3])
False
&gt;&gt;&gt; callable(None)
False
&gt;&gt;&gt; callable(&apos;str&apos;)
False

class urls(Chain):
    def __init__(self, path=&apos;/users&apos;):
    self.__path = path

    def __getattr__(self, path):
        return urls((&apos;%s/%s&apos; % (self.__path, path)))

    def __call__(self, path):
        return urls((&apos;%s/%s&apos; % (self.__path, path)))

    def __str__(self):
        return self.__path

    __repr__ = __str__
</code></pre>
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/python/" rel="tag"># python</a>
          
            <a href="/tags/基础知识/" rel="tag"># 基础知识</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/05/27/network_learning/" rel="next" title="计算机网络学习笔记">
                <i class="fa fa-chevron-left"></i> 计算机网络学习笔记
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Weidong Ji</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#数据类型和变量"><span class="nav-number">1.</span> <span class="nav-text">数据类型和变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数"><span class="nav-number">2.</span> <span class="nav-text">函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#函数的参数"><span class="nav-number">2.1.</span> <span class="nav-text">函数的参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数高级特性"><span class="nav-number">2.2.</span> <span class="nav-text">函数高级特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#迭代器"><span class="nav-number">2.3.</span> <span class="nav-text">迭代器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数式编程"><span class="nav-number">3.</span> <span class="nav-text">函数式编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#高阶函数"><span class="nav-number">3.1.</span> <span class="nav-text">高阶函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#map-reduce"><span class="nav-number">3.2.</span> <span class="nav-text">map()/reduce()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#返回函数"><span class="nav-number">3.3.</span> <span class="nav-text">返回函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#装饰器"><span class="nav-number">3.4.</span> <span class="nav-text">装饰器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#模块"><span class="nav-number">4.</span> <span class="nav-text">模块</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面向对象编程"><span class="nav-number">5.</span> <span class="nav-text">面向对象编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#继承和多态"><span class="nav-number">5.1.</span> <span class="nav-text">继承和多态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#获取对象信息"><span class="nav-number">5.2.</span> <span class="nav-text">获取对象信息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实例属性和类属性"><span class="nav-number">5.3.</span> <span class="nav-text">实例属性和类属性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面向对象高级编程"><span class="nav-number">6.</span> <span class="nav-text">面向对象高级编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#多重继承"><span class="nav-number">6.1.</span> <span class="nav-text">多重继承</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#定制类"><span class="nav-number">7.</span> <span class="nav-text">定制类</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Weidong Ji</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>

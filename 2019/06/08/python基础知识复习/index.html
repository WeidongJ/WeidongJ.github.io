<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","images":"/images","scheme":"Mist","version":"8.3.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"changyan","storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}};
  </script>
<meta name="description" content="python基础知识">
<meta property="og:type" content="article">
<meta property="og:title" content="python基础知识复习">
<meta property="og:url" content="http://yoursite.com/2019/06/08/python%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0/index.html">
<meta property="og:site_name" content="PrueMat">
<meta property="og:description" content="python基础知识">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://yoursite.com/2019/06/08/python%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0/encode.png">
<meta property="og:image" content="http://yoursite.com/2019/06/08/python%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0/DAG.jpg">
<meta property="og:image" content="http://yoursite.com/2019/06/08/python%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0/topo_sorted.webp">
<meta property="article:published_time" content="2019-06-08T01:39:01.000Z">
<meta property="article:modified_time" content="2021-04-24T14:35:17.798Z">
<meta property="article:author" content="Weidong Ji">
<meta property="article:tag" content="python">
<meta property="article:tag" content="基础知识">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/2019/06/08/python%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0/encode.png">


<link rel="canonical" href="http://yoursite.com/2019/06/08/python%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>
<title>python基础知识复习 | PrueMat</title>
  




  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">PrueMat</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档</a></li>
        <li class="menu-item menu-item-schedule"><a href="/schedule/" rel="section"><i class="calendar fa-fw"></i>日程表</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#python%E8%A7%A3%E9%87%8A%E5%99%A8"><span class="nav-number">1.</span> <span class="nav-text">python解释器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%8F%98%E9%87%8F"><span class="nav-number">2.</span> <span class="nav-text">数据类型和变量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%A0%81"><span class="nav-number">2.1.</span> <span class="nav-text">二进制码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">3.</span> <span class="nav-text">数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84"><span class="nav-number">3.1.</span> <span class="nav-text">数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E5%85%B8"><span class="nav-number">3.2.</span> <span class="nav-text">字典</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#set"><span class="nav-number">3.3.</span> <span class="nav-text">set</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0"><span class="nav-number">4.</span> <span class="nav-text">函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0"><span class="nav-number">4.1.</span> <span class="nav-text">函数的参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7"><span class="nav-number">4.2.</span> <span class="nav-text">函数高级特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-number">4.3.</span> <span class="nav-text">迭代器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B"><span class="nav-number">5.</span> <span class="nav-text">函数式编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0"><span class="nav-number">5.1.</span> <span class="nav-text">高阶函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#map-reduce"><span class="nav-number">5.2.</span> <span class="nav-text">map()&#x2F;reduce()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%94%E5%9B%9E%E5%87%BD%E6%95%B0"><span class="nav-number">5.3.</span> <span class="nav-text">返回函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="nav-number">5.4.</span> <span class="nav-text">装饰器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A8%A1%E5%9D%97"><span class="nav-number">6.</span> <span class="nav-text">模块</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B"><span class="nav-number">7.</span> <span class="nav-text">面向对象编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E6%80%81"><span class="nav-number">7.1.</span> <span class="nav-text">继承和多态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E5%AF%B9%E8%B1%A1%E4%BF%A1%E6%81%AF"><span class="nav-number">7.2.</span> <span class="nav-text">获取对象信息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7%E5%92%8C%E7%B1%BB%E5%B1%9E%E6%80%A7"><span class="nav-number">7.3.</span> <span class="nav-text">实例属性和类属性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B"><span class="nav-number">8.</span> <span class="nav-text">面向对象高级编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF"><span class="nav-number">8.1.</span> <span class="nav-text">多重继承</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9A%E5%88%B6%E7%B1%BB"><span class="nav-number">9.</span> <span class="nav-text">定制类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB"><span class="nav-number">9.1.</span> <span class="nav-text">枚举类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%85%83%E7%B1%BB"><span class="nav-number">9.2.</span> <span class="nav-text">使用元类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E5%92%8C%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="nav-number">10.</span> <span class="nav-text">异常和错误处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IO%E7%BC%96%E7%A8%8B"><span class="nav-number">11.</span> <span class="nav-text">IO编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96"><span class="nav-number">11.1.</span> <span class="nav-text">序列化</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Weidong Ji</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">7</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/WeidongJ" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;WeidongJ" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/WeidongJ" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/08/python%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Weidong Ji">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PrueMat">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          python基础知识复习
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-06-08 09:39:01" itemprop="dateCreated datePublished" datetime="2019-06-08T09:39:01+08:00">2019-06-08</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-04-24 22:35:17" itemprop="dateModified" datetime="2021-04-24T22:35:17+08:00">2021-04-24</time>
      </span>

  
</div>

            <div class="post-description">python基础知识</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h2 id="python解释器"><a href="#python解释器" class="headerlink" title="python解释器"></a>python解释器</h2><ul>
<li>CPython 官方解释器，使用最广的解释器，C语言开发</li>
<li>IPython 交互式解释器，相比CPython在交互上有所增强，其他没有区别</li>
<li>PyPy 采用JIT技术，对python代码进行动态编译（不是解释），可以显著提高python的执行速度</li>
<li>JPython是运行在Java平台上的python解释器</li>
<li>IronPython是运行在.net上的解释器</li>
</ul>
<h2 id="数据类型和变量"><a href="#数据类型和变量" class="headerlink" title="数据类型和变量"></a>数据类型和变量</h2><h3 id="二进制码"><a href="#二进制码" class="headerlink" title="二进制码"></a>二进制码</h3><ol>
<li><p>机器数</p>
<p> 一个数在计算机中的二进制表示形式,  叫做这个数的机器数。机器数是带符号的，在计算机用一个数的最高位存放符号, 正数为0, 负数为1.</p>
<p> 比如，十进制中的数 +3 ，计算机字长为8位，转换成二进制就是00000011。如果是 -3 ，就是 10000011 。</p>
<p> 那么，这里的 00000011 和 10000011 就是机器数。</p>
</li>
<li><p>真值</p>
<p> 因为第一位是符号位，所以机器数的形式值就不等于真正的数值。例如上面的有符号数 10000011，其最高位1代表负，其真正数值是 -3 而不是形式值131（10000011转换成十进制等于131）。所以，为区别起见，将带符号位的机器数对应的真正数值称为机器数的真值。</p>
<p> 例：0000 0001的真值 = +000 0001 = +1，1000 0001的真值 = –000 0001 = –1</p>
</li>
<li><p>原码, 反码, 补码的基础概念和计算方法.</p>
<ol>
<li><p>原码</p>
<p> 原码就是符号位加上真值的绝对值，即用第一位表示符号，其余位表示值，比如8位二进制：</p>
<pre><code>[+1]原 = 0000 0001

[-1]原 = 1000 0001</code></pre><p> 第一位是符号位。因为第一位是符号位，所以8位二进制的取值范围是-127～127。</p>
<pre><code>[1111 1111 , 0111 1111]</code></pre></li>
<li><p>反码</p>
<p> 反码的表示方式：正数的反码就是其本身，负数的反码是在其原码的基础上，符号位不变，其余各个位取反：</p>
<pre><code>[+1] = [00000001]原 = [00000001]反

[-1] = [10000001]原 = [11111110]反</code></pre></li>
<li><p>补码</p>
<p> 补码的表示方式：正数的补码就是其本身，负数的补码就是在其原码的基础上，符号位不变，其余各位取反，最后+1。（即在反码的基础上+1）。</p>
<pre><code>[+1] = [00000001]原 = [00000001]反 = [00000001]补

[-1] = [10000001]原 = [11111110]反 = [11111111]补</code></pre></li>
</ol>
</li>
<li><p>用途：使用补码, 不仅仅修复了0的符号以及存在两个编码的问题, 而且还能够多表示一个最低数. 这就是为什么8位二进制, 使用原码或反码表示的范围为[-127, +127], 而使用补码表示的范围为[-128, 127].</p>
</li>
<li><p>原理：</p>
<ol>
<li><p>同余<br> 两个整数a，b，若它们除以整数m所得的余数相等，则称a，b对于模m同余</p>
<p> 记作 a ≡ b (mod m)</p>
<p> 读作 a 与 b 关于模 m 同余。</p>
</li>
<li><p>一个数的反码, 实际上是这个数对于一个模的同余数. 而这个模并不是我们的二进制, 而是所能表示的最大值! 这就和钟表一样, 转了一圈后总能找到在可表示范围内的一个正确的数值!</p>
</li>
<li><p>其实, 在反码的基础上+1, 只是相当于增加了模的值，表盘相当于每128个刻度转一轮. 所以用补码表示的运算结果最小值和最大值应该是[-128, 128].但是由于0的特殊情况, 没有办法表示128, 所以补码的取值范围是[-128, 127]。</p>
</li>
</ol>
</li>
</ol>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ul>
<li>整型</li>
<li>浮点型</li>
<li>字符串</li>
<li>布尔</li>
<li>常量（大写字母表示）</li>
</ul>
<p>Tips</p>
<ul>
<li><p>python中int没有大小限制， 无限大可以使用<code>inf</code>来表示；常量通常使用大写字母表示。</p>
</li>
<li><p><code>utf-8</code>是可变长编码：可以根据一个Unicode字符根据字节大小编码成1-6个字节；计算机中编码的工作方式如下：</p>
<p>  用记事本编辑的时候，从文件读取的UTF-8字符被转换为Unicode字符到内存里，编辑完成后，保存的时候再把Unicode转换为UTF-8保存到文件。内存中是unicode，存储器中是utf-8。</p>
<img src="/2019/06/08/python%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0/encode.png" class="" title="encode"></li>
<li><p><code>ord()</code>函数可以获取字符的整数表示，<code>chr()</code>可以把编码转换成对应的字符。</p>
</li>
<li><p>bytes类型的数据用<code>b&#39;ABC&#39;</code>表示，与字符串<code>ABC</code>的差别是bytes类型每个字符只占一个字节。把字符串转换成bytes型使用<code>encode()</code>方法，使用<code>decode()</code>可以把bytes转换成字符串，<code>len()</code>计算<code>str</code>的字符数，计算<code>bytes</code>的字节数。</p>
<pre><code>&gt;&gt;&gt; &apos;中文&apos;.encode(&apos;utf-8&apos;)
b&apos;\xe4\xb8\xad\xe6\x96\x87&apos;</code></pre></li>
</ul>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>常用方法</p>
<ul>
<li>l.append() 追加元素到末尾</li>
<li>l.insert(index,’value’) 插入到指定的位置</li>
<li>l.pop(index) 删除指定位置的元素，不传默认删除最后一个字符，返回value</li>
</ul>
<p>tuple</p>
<p>tuple和list非常类似，但是tuple一旦初始化就不能修改（每个元素的指向都是不变的），使的代码更加的安全。</p>
<p>定义tuple，只有一个元素<code>t = (1,)</code></p>
<p><code>range(6)</code>默认起点是0，<code>range(2, 12, 2)</code>设置起点，终点和步进</p>
<h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><ul>
<li><p>dict的key必须是不可变对象，因为dict是根据key来计算存储位置，key可变，dict内部就全乱了。</p>
</li>
<li><p><strong>zip()</strong>：函数用于将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的列表，如果各个迭代器的元素个数不一致，则返回列表长度与最短的对象相同，利用 * 号操作符，可以将元组解压为列表。</p>
<pre><code>&gt;&gt;&gt;a = [1,2,3]
&gt;&gt;&gt; b = [4,5,6]
&gt;&gt;&gt; c = [4,5,6,7,8]
&gt;&gt;&gt; zipped = zip(a,b)     # 打包为元组的列表
[(1, 4), (2, 5), (3, 6)]
&gt;&gt;&gt; zip(a,c)              # 元素个数与最短的列表一致
[(1, 4), (2, 5), (3, 6)]
&gt;&gt;&gt; zip(*zipped)          # 与 zip 相反，*zipped 可理解为解压，返回二维矩阵式
[(1, 2, 3), (4, 5, 6)]</code></pre></li>
</ul>
<h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>set和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key。</p>
<p>创建方式<code>s = set([1, 2, 3])</code></p>
<p>基本方法</p>
<ol>
<li>add <code>s.add(4)</code> </li>
<li>remove <code>s.remove(4)</code></li>
<li>支持交集并集操作</li>
</ol>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数名其实就是指向一个函数对象的引用，完全可以把函数名赋给一个变量，相当于给这个函数起了一个“别名”：</p>
<pre><code>&gt;&gt;&gt; a = abs # 变量a指向abs函数
&gt;&gt;&gt; a(-1) # 所以也可以通过a调用abs函数
1</code></pre><h3 id="函数的参数"><a href="#函数的参数" class="headerlink" title="函数的参数"></a>函数的参数</h3><p>默认参数</p>
<pre><code>def power(x, n=2):
    s = 1
    while n &gt; 0:
        n = n - 1
        s = s * x
    return s</code></pre><p>默认参数必须指向不变对象：Python函数在定义的时候，默认参数L的值就被计算出来了，即<code>[]</code>，因为默认参数L也是一个变量，它指向对象<code>[]</code>，每次调用该函数，如果改变了L的内容，则下次调用时，默认参数的内容就变了，不再是函数定义时的<code>[]</code>了。</p>
<pre><code>def add_end(L=[]):
    L.append(&apos;END&apos;)
    return L

&gt;&gt;&gt; add_end() #使用了默认参数，改变了其值
[&apos;END&apos;, &apos;END&apos;]
&gt;&gt;&gt; add_end()
[&apos;END&apos;, &apos;END&apos;, &apos;END&apos;]</code></pre><p>可变参数：<br>    def calc(*numbers):<br>        sum = 0<br>        for n in numbers:<br>            sum = sum + n * n<br>        return sum<br>*nums表示把nums这个list的所有元素作为可变参数传进去。这种写法相当有用，而且很常见：</p>
<pre><code>&gt;&gt;&gt; nums = [1, 2, 3]
&gt;&gt;&gt; calc(*nums)
14</code></pre><p>关键字参数</p>
<p>关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict，传入参数时可以直接传入dict</p>
<pre><code>def person(name, age, **kw):
    print(&apos;name:&apos;, name, &apos;age&apos;, age, &apos;other&apos;,kw)</code></pre><p>使用递归需要注意防止栈溢出。可以使用尾递归优化，尾递归即调用自己本身时 return语句不包含表达式，效果等同于循环。</p>
<pre><code># 汉诺塔移动
def move(n, a, b, c):
    if n == 1:
        print(a, &apos;--&gt;&apos;, c)
    else:
        move(n-1, a, c, b)
        move(1, a, b, c)
        move(n-1, b, c, a)</code></pre><h3 id="函数高级特性"><a href="#函数高级特性" class="headerlink" title="函数高级特性"></a>函数高级特性</h3><p>切片不包含后边界<br>    &gt;&gt;&gt; L[0:3] # 取 0，1，2 元素<br>    [‘Michael’, ‘Sarah’, ‘Tracy’]<br>python内置函数<code>enumerate()</code>可以把列表变成一个索引-元素对。</p>
<pre><code>&gt;&gt;&gt; for i, value in enumerate([&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]):
...     print(i, value)
...
0 A
1 B
2 C</code></pre><p><strong>生成器（generate）</strong>：列表元素根据某种算法推算出来，循环中不断推算出后面的数，不需要创建完整的列表，以节省大量的空间；使用()创建一个生成器，列表生成式使用[]，使用next()获取下一个返回值，最后抛出StopIteration异常。调用生成器返回一个generator对象</p>
<p>斐波拉契数列：</p>
<pre><code># 列表生成式
def fib(x):
    n, a, b = 0, 0, 1
    while n &lt; max:
        print(b)
        a, b = a, a + b
        n += 1
    return &apos;done&apos;</code></pre><p>generator的另一种方法。如果一个函数定义中包含yield关键字，那么这个函数就不再是一个普通函数，而是一个generator：</p>
<pre><code># 生成器
def fib(x):
    n, a, b = 0, 0, 1
    while n &lt; max:
        yield b
        a, b = a, a + b
        n += 1
    return &apos;done&apos;</code></pre><p>最难理解的就是generator和函数的执行流程不一样。函数是顺序执行，遇到return语句或者最后一行函数语句就返回。而变成generator的函数，<strong>在每次调用next()的时候执行，遇到yield语句返回，再次执行时从上次返回的yield语句处继续执行。</strong></p>
<pre><code>def odd():
print(&apos;step 1&apos;)
yield 1
print(&apos;step 2&apos;)
yield(3)
print(&apos;step 3&apos;)
yield(5)

&gt;&gt;&gt; o = odd()
&gt;&gt;&gt; next(o)
step 1
1
&gt;&gt;&gt; next(o)
step 2
3
&gt;&gt;&gt; next(o)
step 3
5
&gt;&gt;&gt; next(o)
Traceback (most recent call last):
File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
StopIteration</code></pre><p>杨辉三角：<br>    def trangles():<br>        L = [1]<br>        while True:<br>            yield L<br>            L = [1] + [L[a] + L[a+1] for a in range(0,len(L)-1)] + [1]</p>
<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><ul>
<li>可以直接作用于for循环的对象统称为可迭代对象：<strong>Iterable</strong>。</li>
<li>可以被next()函数调用并不断返回下一个值的对象称为迭代器：<strong>Iterator</strong>。</li>
</ul>
<p>Python的Iterator对象表示的是一个数据流，Iterator对象可以被next()函数调用并不断返回下一个数据，直到没有数据时抛出StopIteration错误。可以把这个数据流看做是一个有序序列，但我们却不能提前知道序列的长度，只能不断通过next()函数实现按需计算下一个数据，所以Iterator的计算是惰性的，只有在需要返回下一个数据时它才会计算。Iterator甚至可以表示一个无限大的数据流，例如全体自然数。而使用list是永远不可能存储全体自然数的。</p>
<p>Python的for循环本质上就是通过不断调用next()函数实现的</p>
<h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h2><p>函数式编程就是一种抽象程度很高的编程范式，纯粹的函数式编程语言编写的函数没有变量，因此，任意一个函数，只要输入是确定的，输出就是确定的，这种纯函数我们称之为没有副作用。而允许使用变量的程序设计语言，由于函数内部的变量状态不确定，同样的输入，可能得到不同的输出，因此，这种函数是有副作用的。</p>
<p>函数式编程的一个特点就是，允许把函数本身作为参数传入另一个函数，还允许返回一个函数！</p>
<h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><p>一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数</p>
<p>变量可以指向函数</p>
<pre><code>&gt;&gt;&gt; f = abs
&gt;&gt;&gt; f(-10)
10</code></pre><h3 id="map-reduce"><a href="#map-reduce" class="headerlink" title="map()/reduce()"></a>map()/reduce()</h3><p><code>map()</code>函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的<strong>Iterator</strong>返回。</p>
<pre><code>&gt;&gt;&gt; list(map(str, [1, 2, 3, 4, 5, 6, 7, 8, 9]))
[&apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos;]</code></pre><p><code>reduce()</code>把一个函数作用在一个序列[x1, x2, x3, …]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算，其效果就是。</p>
<pre><code>&gt;&gt;&gt; from functools import reduce
&gt;&gt;&gt; def add(x, y):
...     return x + y
...
&gt;&gt;&gt; reduce(add, [1, 3, 5, 7, 9])
25</code></pre><p><code>filter()</code>也接收一个函数和一个序列。和map()不同的是，filter()把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素,返回一个<strong>Iterator</strong>。</p>
<pre><code># 实现一个素数函数
def _odd_iter():
    n = 1
    while True:
        n += 2
        yield n

def _not_divisible(n):
    return lambda x: x % n &gt; 0

def primes():
    yield 2
    it = _odd_iter()
    while True:
        n = next(it)
        yield n
        it = filter(_not_divisible(n), it)</code></pre><p><code>sorted()</code>排序</p>
<pre><code>&gt;&gt;&gt; sorted([&apos;bob&apos;, &apos;about&apos;, &apos;Zoo&apos;, &apos;Credit&apos;], key=str.lower, reverse=True)
[&apos;Zoo&apos;, &apos;Credit&apos;, &apos;bob&apos;, &apos;about&apos;]</code></pre><h3 id="返回函数"><a href="#返回函数" class="headerlink" title="返回函数"></a>返回函数</h3><p>高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回。</p>
<pre><code>def lazy_sum(*args):
    def sum():
        ax = 0
        for n in args:
            ax = ax + n
        return ax
    return sum</code></pre><p>调用<code>lazy_sum()</code>时，返回求和函数；并且每次调用时都返回一个新的函数：</p>
<pre><code>&gt;&gt;&gt; f = lazy_sum(1, 3, 5, 7, 9)
&gt;&gt;&gt; f
&lt;function lazy_sum.&lt;locals&gt;.sum at 0x101c6ed90&gt;

&gt;&gt;&gt; f1 = lazy_sum(1, 3, 5, 7, 9)
&gt;&gt;&gt; f2 = lazy_sum(1, 3, 5, 7, 9)
&gt;&gt;&gt; f1==f2
False</code></pre><p>闭包：我们在函数<code>lazy_sum</code>中又定义了函数<code>sum</code>，并且，内部函数<code>sum</code>可以引用外部函数<code>lazy_sum</code>的参数和局部变量，当<code>lazy_sum</code>返回函数<code>sum</code>时，<strong>相关参数和变量都保存在返回的函数中</strong>，这种称为“闭包（Closure）”的程序结构拥有极大的威力。</p>
<p>返回的函数并没有立刻执行，而是直到调用了f()才执行。</p>
<pre><code>def count():
    fs = []
    for i in range(1, 4):
        def f():
            return i*i
        fs.append(f)
    return fs

f1, f2, f3 = count()
&gt;&gt;&gt; f1()
9
&gt;&gt;&gt; f2()
9
&gt;&gt;&gt; f3()
9</code></pre><p>全部都是9！原因就在于返回的函数引用了变量i，但它并非立刻执行。等到3个函数都返回时，它们所引用的变量i已经变成了3，因此最终结果为9。<strong>返回闭包时牢记一点：返回函数不要引用任何循环变量，或者后续会发生变化的变量。</strong></p>
<p>一定要引用循环变量怎么办？方法是再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变:<br>    def count():<br>        def f(j):<br>            def g():<br>                return j*j<br>            return g<br>        fs = []<br>        for i in range(1, 4):<br>            fs.append(f(i)) # f(i)立刻被执行，因此i的当前值被传入f()<br>        return fs # 返回一个列表</p>
<p>计数器：</p>
<pre><code>def createCounter():
    li = 0
    def counter():
        li += 1
        return li
    return counter</code></pre><p>上述代码会报错：当你在当前作用域中的给变量赋值时，该变量将成为该作用域的局部变量，并在外部范围中隐藏任何类似命名的变量。</p>
<pre><code>def createCounter():
    l = [0]
    def counter():
        l[0] = l[0] + 1
        return l[0]
    return counter</code></pre><h3 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h3><p>在代码运行期间动态增加功能的方式，成为<strong>装饰器（Decorator）</strong>；本质上decorator就是一个返回函数的高阶函数。</p>
<pre><code># 装饰器
def log(func):
    @functools.wraps(func)
    def wrapper(*args, **kw):
        print(&apos;call %s()&apos; % func.__name__)
        return func(*args, **kw)
    return wrapper

@log
def now():
    print(&apos;Hello World!&apos;)

def log_text(text):
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kw):
            print(&apos;%s %s()&apos; % (text, func.__name__))
            return func(*args, **kw)
        return wrapper
    return decorator

@log_text(&apos;调用&apos;)
def new_now():
    print(&apos;Hello World!&apos;)</code></pre><p>Python内置的<code>functools.wraps</code>，把原始函数的<code>__name__</code>属性复制到<code>wrapper()</code>中.</p>
<p>偏函数</p>
<p><code>functools.partial</code>的作用就是，把一个函数的某些参数给固定住（也就是设置默认值），返回一个新的函数，调用这个新函数会更简单。</p>
<pre><code>&gt;&gt;&gt; import functools
&gt;&gt;&gt; int2 = functools.partial(int, base=2)
&gt;&gt;&gt; int2(&apos;1000000&apos;)
64</code></pre><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p><code>sys</code>模块有一个<code>argv</code>变量，用list存储了命令行的所有参数。运行python3 hello.py Michael获得的sys.argv就是[‘hello.py’, ‘Michael]。</p>
<p>当我们在命令行运行hello模块文件时，Python解释器把一个特殊变量<code>__name__</code>置为<code>__main__</code>，而如果在其他地方导入该hello模块时，if判断将失败，因此，这种if测试可以让一个模块通过命令行运行时执行一些额外的代码，最常见的就是运行测试</p>
<pre><code>if __name__==&apos;__main__&apos;:
test()</code></pre><h2 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h2><p>类和实例</p>
<p>和静态语言不同，Python允许对实例变量绑定任何数据，也就是说，对于两个实例变量，虽然它们都是同一个类的不同实例，但拥有的变量名称都可能不同。</p>
<p>访问限制</p>
<p>使用<code>__</code>限制属性访问，改为增加<code>get/se</code>t方法是因为<strong>在方法中可以对参数做检查</strong>。</p>
<ul>
<li><code>__xxx__</code> 特殊变量。</li>
<li><code>_xxx</code> 约定的私有变量：虽然我可以被访问，但是，请把我视为私有变量，不要随意访问。</li>
<li><code>__xx</code> 私有变量，python解释器把<code>__xx</code>对外改变成<code>_ClassName__xx</code></li>
</ul>
<p>外部设置变量错误，际上这个<strong>name变量和class内部的</strong>name变量不是一个变量！内部的<strong>name变量已经被Python解释器自动改成了_Student</strong>name，而外部代码给bart新增了一个__name变量：</p>
<pre><code>&gt;&gt;&gt; bart = Student(&apos;Bart Simpson&apos;, 59)
&gt;&gt;&gt; bart.get_name()
&apos;Bart Simpson&apos;
&gt;&gt;&gt; bart.__name = &apos;New Name&apos; # 设置__name变量！
&gt;&gt;&gt; bart.__name
&apos;New Name&apos;</code></pre><h3 id="继承和多态"><a href="#继承和多态" class="headerlink" title="继承和多态"></a>继承和多态</h3><p><strong>继承</strong>：子类获得了父类的全部功能。</p>
<p><strong>多态</strong>：对于一个变量，我们只需要知道它是Animal类型，无需确切地知道它的子类型，就可以放心地调用run()方法，而具体调用的run()方法是作用在Animal、Dog、Cat还是Tortoise对象上，由运行时该对象的确切类型决定，这就是多态真正的威力：调用方只管调用，不管细节，而当我们新增一种Animal的子类时，只要确保run()方法编写正确，不用管原来的代码是如何调用的。这就是著名的“开闭”原则：</p>
<pre><code>class Animal(object):
def run(self):
    print(&apos;Animal is running...&apos;)

class Dog(Animal):
    def run(self):
        print(&apos;Dog is running...&apos;)

def run_twice(animal):
    animal.run()
    animal.run()

run_twice(Animal())
run_twice(Dog())

Animal is running...
Animal is running...
Dog is running...
Dog is running...</code></pre><ul>
<li>对扩展开放：允许新增Animal子类。</li>
<li>对修改封闭：不需要修改依赖Animal类型的run_twice()等函数。</li>
</ul>
<p>动态语言vs静态语言</p>
<p>对于静态语言（例如Java）来说，如果需要传入Animal类型，则传入的对象必须是Animal类型或者它的子类，否则，将无法调用run()方法。</p>
<p>对于Python这样的动态语言来说，则不一定需要传入Animal类型。我们只需要保证传入的对象有一个run()方法就可以了：</p>
<pre><code>class Timer(object):
    def run(self):
        print(&apos;start...&apos;)

run_twice(Timer())

start...
start...</code></pre><p>这就是动态语言的“<strong>鸭子类型</strong>”，它并不要求严格的继承体系，一个对象只要“看起来像鸭子，走起路来像鸭子”，那它就可以被看做是鸭子。</p>
<h3 id="获取对象信息"><a href="#获取对象信息" class="headerlink" title="获取对象信息"></a>获取对象信息</h3><p><code>type()</code>用于判断对象的类型,使用<code>isinstance()</code>判断继承关系。</p>
<p><code>dir()</code>获取对象的所有属性，实际上<code>len()</code>方法是自动调用该对象的<code>__len__()</code>方法</p>
<p>配合<code>getattr()</code>、<code>setattr()</code>以及<code>hasattr()</code>，我们可以直接操作一个对象的状态:</p>
<pre><code>&gt;&gt;&gt; class MyObject(object):
...     def __init__(self):
...         self.x = 9
...     def power(self):
...         return self.x * self.x
...
&gt;&gt;&gt; obj = MyObject()

&gt;&gt;&gt; hasattr(obj, &apos;x&apos;) # 有属性&apos;x&apos;吗？
True
&gt;&gt;&gt; obj.x
9
&gt;&gt;&gt; hasattr(obj, &apos;y&apos;) # 有属性&apos;y&apos;吗？
False
&gt;&gt;&gt; setattr(obj, &apos;y&apos;, 19) # 设置一个属性&apos;y&apos;
&gt;&gt;&gt; hasattr(obj, &apos;y&apos;) # 有属性&apos;y&apos;吗？
True
&gt;&gt;&gt; getattr(obj, &apos;y&apos;) # 获取属性&apos;y&apos;
19
&gt;&gt;&gt; obj.y # 获取属性&apos;y&apos;
19</code></pre><h3 id="实例属性和类属性"><a href="#实例属性和类属性" class="headerlink" title="实例属性和类属性"></a>实例属性和类属性</h3><p>不可对实例属性和类属性使用相同的名字，因为相同名称的实例属性将屏蔽掉类属性，但是当你删除实例属性后，再使用相同的名称，访问到的将是类属性。</p>
<pre><code>&gt;&gt;&gt; class Student(object):
...     name = &apos;Student&apos;
...
&gt;&gt;&gt; s = Student() # 创建实例s
&gt;&gt;&gt; print(s.name) # 打印name属性，因为实例并没有name属性，所以会继续查找class的name属性
Student
&gt;&gt;&gt; print(Student.name) # 打印类的name属性
Student
&gt;&gt;&gt; s.name = &apos;Michael&apos; # 给实例绑定name属性
&gt;&gt;&gt; print(s.name) # 由于实例属性优先级比类属性高，因此，它会屏蔽掉类的name属性
Michael
&gt;&gt;&gt; print(Student.name) # 但是类属性并未消失，用Student.name仍然可以访问
Student
&gt;&gt;&gt; del s.name # 如果删除实例的name属性
&gt;&gt;&gt; print(s.name) # 再次调用s.name，由于实例的name属性没有找到，类的name属性就显示出来了
Student</code></pre><p>给Student类增加一个类属性，每创建一个实例，该属性自动增加：</p>
<pre><code>class Student(object):
    count = 0

    def __init__(self, name):
        self.name = name
        Student.count += 1 # 访问类属性</code></pre><p>变量的类型：</p>
<ol>
<li>全局变量 - 在所有函数和类的外面</li>
<li>局部变量 -  <ol>
<li>在函数内</li>
<li>在class的方法内，未加 self 修饰</li>
</ol>
</li>
<li>静态变量 - 在class内，并且是在方法外</li>
<li>实例变量 - 在class方法内，用self修饰</li>
</ol>
<h2 id="面向对象高级编程"><a href="#面向对象高级编程" class="headerlink" title="面向对象高级编程"></a>面向对象高级编程</h2><p>给实例绑定一个属性：</p>
<pre><code>class Student(object):
    pass

&gt;&gt;&gt; s = Student()
&gt;&gt;&gt; s.name = &apos;Michael&apos; # 动态给实例绑定一个属性
&gt;&gt;&gt; print(s.name)
Michael</code></pre><p>给实例绑定一个方法：</p>
<pre><code>&gt;&gt;&gt; def set_age(self, age): # 定义一个函数作为实例方法
...     self.age = age
...
&gt;&gt;&gt; from types import MethodType
&gt;&gt;&gt; s.set_age = MethodType(set_age, s) # 给实例绑定一个方法
&gt;&gt;&gt; s.set_age(25) # 调用实例方法
&gt;&gt;&gt; s.age # 测试结果
25</code></pre><p>给类绑定一个方法：</p>
<pre><code>&gt;&gt;&gt; def set_score(self, score):
...     self.score = score
...
&gt;&gt;&gt; Student.set_score = set_scor</code></pre><p>使用<code>__slots__</code>可以限制实例的属性,使用<strong>slots</strong>要注意，<strong>slots</strong>定义的属性仅对当前类实例起作用，对继承的子类是不起作用的。</p>
<pre><code>class Student(object):
    __slots__ = (&apos;name&apos;, &apos;age&apos;) # 用tuple定义允许绑定的属性名称</code></pre><p><code>@property</code>装饰器就是负责把一个方法变成属性调用的:</p>
<pre><code>class Student(object):

    @property
    def score(self):
        return self._score

    @score.setter
    def score(self, value):
        if not isinstance(value, int):
            raise ValueError(&apos;score must be an integer!&apos;)
        if value &lt; 0 or value &gt; 100:
            raise ValueError(&apos;score must between 0 ~ 100!&apos;)
        self._score = value

&gt;&gt;&gt; s = Student()
&gt;&gt;&gt; s.score = 60 # OK，实际转化为s.set_score(60)
&gt;&gt;&gt; s.score # OK，实际转化为s.get_score()
60
&gt;&gt;&gt; s.score = 9999
Traceback (most recent call last):
...
ValueError: score must between 0 ~ 100!</code></pre><p>注意：<code>@property</code> 赋值时需要使用<code>_xx</code></p>
<h3 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h3><p>Mixln：在设计类的继承关系时，通常主线都是翻译继承下来的，但是如果需要“混入”额外的功能，通过多重继承可以实现。这种设计模式通常称为Mixln。Mixln的目的就是给一个类增加多个功能。</p>
<p>tips：多重继承中的属性或者方法重复，遵循取左原则</p>
<pre><code>class A(object):

    def __init__(self):
        self.name = &apos;A&apos;

class B(object):

    def __init__(self):
        self.name = &apos;B&apos;

class C(A, B):
    pass

class D(B, A):
    pass

a = C()
print(a.name)
b = D()
print(b.name)

A
B</code></pre><p>python继承的优先顺序：按照拓扑排序：</p>
<p>在图论中，拓扑排序(Topological Sorting) 是一个 有向无环图(DAG,Directed Acyclic Graph) 的所有顶点的线性序列。且该序列必须满足下面两个条件：</p>
<ul>
<li>每个顶点出现且只出现一次。</li>
<li>若存在一条从顶点A到B的路径，那么序列中顶点A在B的前面。<img src="/2019/06/08/python%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0/DAG.jpg" class="" title="Topological Sorting">

</li>
</ul>
<p>它是一个DAG图，那么如何写出它的拓扑顺序呢？这里说一种比较常用的方法：</p>
<ul>
<li>从DAG途中选择一个没有前驱(即没有指向其的箭头)的顶点并输出。</li>
<li>从图中删除该顶点和所有以它为起点的有向边。</li>
<li>重复1和2直到当前DAG图为空或当前途中不存在无前驱的顶点为止。后一种情况说明有向图中必然存在环。<img src="/2019/06/08/python%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0/topo_sorted.webp" class="" title="Topo_sorted">

</li>
</ul>
<p>python C3算法遍历DAG顺序寻找方法，优先找到即调用。</p>
<h2 id="定制类"><a href="#定制类" class="headerlink" title="定制类"></a>定制类</h2><p><code>__str__()</code>存储了实例的字符串：</p>
<pre><code>class Student(object):
    count = 0

    def __init__(self, name):
        self.name = name
        Student.count += 1 # 访问类属性

    def __str__(self):
        return &apos;Student object (name: %s)&apos; % self.name

print(Student(&apos;wdji&apos;))

Student object (name: wdji)</code></pre><p>直接线是调用的变量还是不好看：</p>
<pre><code>&gt;&gt;&gt; s = Student(&apos;Michael&apos;)
&gt;&gt;&gt; s
&lt;__main__.Student object at 0x109afb310&gt;</code></pre><p>因为直接显示变量调用的不是<code>__str__()</code>，而是<code>__repr__()</code>，两者的区别是<code>__str__()</code>返回用户看到的字符串，而<code>__repr__()</code>返回程序开发者看到的字符串，也就是说，<code>__repr__()</code>是为调试服务的。</p>
<pre><code>class Student(object):
    count = 0

    def __init__(self, name):
        self.name = name
        Student.count += 1 # 访问类属性

    def __str__(self):
        return &apos;Student object (name: %s)&apos; % self.name

    __repr__ == __str__</code></pre><p><code>__iter__()</code>一个类想被<code>for ... in</code>循环，类似list，tuple就必须实现一个<code>__iter__()</code>方法，该方法返回一个迭代对象。</p>
<pre><code>class Fib(object):

    def __init__(self):
        self.a, self.b = 0, 1

    def __iter__(self):
        return self

    def __next__(self):
        self.a , self.b = self.b, self.a + self.b
        if self.a &gt; 1000:
            raise StopIteration()
        return self.a

for n in Fib():
    print(n)

1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987</code></pre><p><code>__getitem__()</code>:实现像list一样取出按照下表取出元素</p>
<pre><code>class Fib(object):

    def __getitem__(self, n):
        a, b = 1, 1
        for x in range(n):
            a, b = b, a + b
        return a

f = Fib()
print(f[5]) # 8</code></pre><p>实现切片需要判断n的类型：</p>
<pre><code>class Fib(object):

    def __getitem__(self, n):
        if isinstance(n, int):
            a, b = 1, 1
            for _ in range(n):
                a, b = b, a + b
            return a
        if isinstance(n, slice):
            start = n.start
            stop = n.stop
            if start is None:
                start = 0
            a, b = 1, 1
            L = []
            for x in range(stop):
                if x &gt;= start:
                    L.append(a)
                a, b = b, a + b
            return L

f = Fib()
print(f[5:10]) # [8, 13, 21, 34, 55]</code></pre><p>以上没有处理step和负数，所以实现一个<code>__getitem__()</code>还有很多工作要做。如果把对象看成dict，<code>__getitem__()</code>的参数也可能是一个可以作key的object，例如str。</p>
<p>与之对应的是<code>__setitem__()</code>方法，把对象视作list或dict来对集合赋值。最后，还有一个<code>__delitem__()</code>方法，用于删除某个元素。通过上面的方法，我们自己定义的类表现得和Python自带的list、tuple、dict没什么区别，这完全归功于动态语言的“鸭子类型”，不需要强制继承某个接口。</p>
<p><code>__getattr__()</code></p>
<p>调用不存在的属性时会报错，可以用<code>__getattr__()</code>实现动态的返回一个属性。</p>
<pre><code>class Student(object):
    count = 0

    def __init__(self, name):
        self.name = name
        Student.count += 1 # 访问类属性

    def __str__(self):
        return &apos;Student object (name: %s)&apos; % self.name

    def __getattr__(self, attr):
        if attr == &apos;age&apos;:
            return lambda: 25
        raise AttributeError(&apos;\&apos;Student\&apos; object has no attribute \&apos;%s\&apos;&apos; % attr)

print(Student(&apos;wdji&apos;))
a = Student(&apos;wdji2&apos;)
print(a.age()) # 25
print(a.grade) # AttributeError: &apos;Student&apos; object has no attribute &apos;grade&apos;</code></pre><p>动态调用的特性可以用在网站的REST API；利用完全动态的<code>__getattr__()</code>写出一个链式调用。</p>
<pre><code>class Chain(object):

    def __init__(self, path=&apos;&apos;):
        self._path = path

    def __getattr__(self, path):
        return Chain(&apos;%s/%s&apos; % (self._path, path))

    def __str__(self):
        return self._path

    __repr__ = __str__</code></pre><p><code>__call__()</code></p>
<p>定义一个<strong>call</strong>()方法，就可以直接对实例进行调用:</p>
<pre><code>class Student(object):
    def __init__(self, name):
        self.name = name

    def __call__(self):
        print(&apos;My name is %s.&apos; % self.name)

&gt;&gt;&gt; s = Student(&apos;Michael&apos;)
&gt;&gt;&gt; s() # self参数不要传入
My name is Michael.</code></pre><p><code>__call__()</code>还可以定义参数。<strong>对实例进行直接调用就好比对一个函数进行调用一样，所以你完全可以把对象看成函数，把函数看成对象，因为这两者之间本来就没啥根本的区别。如果你把对象看成函数，那么函数本身其实也可以在运行期动态创建出来，因为类的实例都是运行期创建出来的，这么一来，我们就模糊了对象和函数的界限</strong>。</p>
<p>那么，怎么判断一个变量是对象还是函数呢？其实，更多的时候，我们需要判断一个对象是否能被调用，能被调用的对象就是一个Callable对象，比如函数和我们上面定义的带有<strong>call</strong>()的类实例：</p>
<pre><code>&gt;&gt;&gt; callable(Student())
True
&gt;&gt;&gt; callable(max)
True
&gt;&gt;&gt; callable([1, 2, 3])
False
&gt;&gt;&gt; callable(None)
False
&gt;&gt;&gt; callable(&apos;str&apos;)
False

class urls(Chain):
    def __init__(self, path=&apos;/users&apos;):
    self.__path = path

    def __getattr__(self, path):
        return urls((&apos;%s/%s&apos; % (self.__path, path)))

    def __call__(self, path):
        return urls((&apos;%s/%s&apos; % (self.__path, path)))

    def __str__(self):
        return self.__path

    __repr__ = __str__</code></pre><h3 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h3><p>定义常量时，可以使用枚举类定义一个class类型。</p>
<pre><code>from enum import Enum

Month = Enum(&apos;Month&apos;, (&apos;Jan&apos;, &apos;Feb&apos;, &apos;Mar&apos;, &apos;Apr&apos;, &apos;May&apos;, &apos;Jun&apos;, &apos;Jul&apos;, &apos;Aug&apos;, &apos;Sep&apos;, &apos;Oct&apos;, &apos;Nov&apos;, &apos;Dec&apos;))</code></pre><p>需要更精确的控制枚举类型，可以从Enum派生自定义类：</p>
<pre><code>from enum import Enum, unique

@unique
class Weekday(Enum):
    Sun = 0 # Sun的value被设定为0
    Mon = 1
    Tue = 2
    Wed = 3
    Thu = 4
    Fri = 5
    Sat = 6</code></pre><h3 id="使用元类"><a href="#使用元类" class="headerlink" title="使用元类"></a>使用元类</h3><p>pass</p>
<h2 id="异常和错误处理"><a href="#异常和错误处理" class="headerlink" title="异常和错误处理"></a>异常和错误处理</h2><p>抛出异常</p>
<pre><code># err_reraise.py

def foo(s):
    n = int(s)
    if n==0:
        raise ValueError(&apos;invalid value: %s&apos; % s)
    return 10 / n

def bar():
    try:
        foo(&apos;0&apos;)
    except ValueError as e:
        print(&apos;ValueError!&apos;)
        raise

bar()</code></pre><p>在bar()函数中，我们明明已经捕获了错误，但是，打印一个ValueError!后，又把错误通过raise语句抛出去了，这不有病么？</p>
<p>其实这种错误处理方式不但没病，而且相当常见。捕获错误目的只是记录一下，便于后续追踪。但是，由于当前函数不知道应该怎么处理该错误，所以，最恰当的方式是继续往上抛，让顶层调用者去处理。好比一个员工处理不了一个问题时，就把问题抛给他的老板，如果他的老板也处理不了，就一直往上抛，最终会抛给CEO去处理。</p>
<p><code>raise</code>语句如果不带参数，就会把当前错误原样抛出。此外，在<code>except</code>中<code>raise</code>一个Error，还可以把一种类型的错误转化成另一种类型。</p>
<h2 id="IO编程"><a href="#IO编程" class="headerlink" title="IO编程"></a>IO编程</h2><h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><p>变量从内存中变成可存储或传输的过程称之为<strong>序列化</strong>。</p>
<p>变量内容从序列化的对象重新读到内存里称之为<strong>反序列化</strong>。</p>
<p>JSON</p>
<pre><code>&gt;&gt;&gt; import json
&gt;&gt;&gt; d = dict(name=&apos;Bob&apos;, age=20, score=88)
&gt;&gt;&gt; json.dumps(d)
&apos;&#123;&quot;age&quot;: 20, &quot;score&quot;: 88, &quot;name&quot;: &quot;Bob&quot;&#125;&apos;</code></pre><p>dumps()方法返回一个str，内容就是标准的JSON。类似的，dump()方法可以直接把JSON写入一个file-like Object。</p>
<p>要把JSON反序列化为Python对象，用loads()或者对应的load()方法，前者把JSON的字符串反序列化，后者从file-like Object中读取字符串并反序列化：</p>
<pre><code>&gt;&gt;&gt; json_str = &apos;&#123;&quot;age&quot;: 20, &quot;score&quot;: 88, &quot;name&quot;: &quot;Bob&quot;&#125;&apos;
&gt;&gt;&gt; json.loads(json_str)
&#123;&apos;age&apos;: 20, &apos;score&apos;: 88, &apos;name&apos;: &apos;Bob&apos;&#125;</code></pre>
    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/python/" rel="tag"># python</a>
              <a href="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" rel="tag"># 基础知识</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2019/05/27/network_learning/" rel="prev" title="计算机网络学习笔记">
                  <i class="fa fa-chevron-left"></i> 计算机网络学习笔记
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2020/05/11/docker%E5%85%A5%E9%97%A8%E4%B8%8E%E5%AE%9E%E8%B7%B5/" rel="next" title="docker入门与实践">
                  docker入门与实践 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>







<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Weidong Ji</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
